<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>vue学习笔记 | yxx</title><meta name="author" content="yxx"><meta name="copyright" content="yxx"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="第一天 创建一个vue实例 vue是用于构造用户界面的渐进式框架 &lt;body&gt;   &lt;!--      创建vue实例     1.创建一个盒子     2.引入vue的开发包     3.创建一个vue实例     4.实例中，有两个配置项，       el:用来指定盒子       data:用来指定数据    --&gt;    &lt;!-- 1.创建一个盒子 --&amp;g">
<meta property="og:type" content="article">
<meta property="og:title" content="vue学习笔记">
<meta property="og:url" content="http://example.com/2024/02/17/vue/index.html">
<meta property="og:site_name" content="yxx">
<meta property="og:description" content="第一天 创建一个vue实例 vue是用于构造用户界面的渐进式框架 &lt;body&gt;   &lt;!--      创建vue实例     1.创建一个盒子     2.引入vue的开发包     3.创建一个vue实例     4.实例中，有两个配置项，       el:用来指定盒子       data:用来指定数据    --&gt;    &lt;!-- 1.创建一个盒子 --&amp;g">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png">
<meta property="article:published_time" content="2024-02-17T13:12:54.255Z">
<meta property="article:modified_time" content="2024-02-17T13:22:14.693Z">
<meta property="article:author" content="yxx">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://example.com/2024/02/17/vue/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css?v=4.12.0"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.5.1/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.32/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid@4.11.0/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'vue学习笔记',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: false,
  postUpdate: '2024-02-17 21:22:14'
}</script><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
        if (t === 'dark') activateDarkMode()
        else if (t === 'light') activateLightMode()
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><meta name="generator" content="Hexo 7.1.1"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">2</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">0</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><hr class="custom-hr"/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> List</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> Music</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> Movie</span></a></li><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> Link</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header"><nav id="nav"><span id="blog-info"><a href="/" title="yxx"><span class="site-name">yxx</span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> List</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> Music</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> Movie</span></a></li><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> Link</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">vue学习笔记</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2024-02-17T13:12:54.255Z" title="发表于 2024-02-17 21:12:54">2024-02-17</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-02-17T13:22:14.693Z" title="更新于 2024-02-17 21:22:14">2024-02-17</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="vue学习笔记"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><p>第一天</p>
<p>创建一个vue实例</p>
<p>vue是用于构造用户界面的渐进式框架</p>
<pre><code>&lt;body&gt;
  &lt;!-- 
    创建vue实例
    1.创建一个盒子
    2.引入vue的开发包
    3.创建一个vue实例
    4.实例中，有两个配置项，
      el:用来指定盒子
      data:用来指定数据
   --&gt;

  &lt;!-- 1.创建一个盒子 --&gt;
  &lt;div class=&quot;App&quot;&gt;
    &lt;!-- 用来页面渲染的地方 --&gt;
    &#123;&#123;mas&#125;&#125;
  &lt;/div&gt;

  &lt;!-- 2.引入vue的开发包 --&gt;
  &lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue@2.7.16/dist/vue.js&quot;&gt;&lt;/script&gt;
  &lt;script&gt;
    // 创建一个vue实例，注：应该写在new vue(&#123;中&#125;)
    const App = new Vue(&#123;
      //  el:用来指定盒子
      el: &#39;.App&#39;,
      // data:用来指定数据
      data: &#123;
        mas: &#39;hello,word&#39;
      &#125;
    &#125;)
  &lt;/script&gt;

&lt;/body&gt;
</code></pre>
<p>插值表达式</p>
<p>语法：，注：表达式为能够求出值的表达式（加减乘除，三元等）而非语句（if，for等）</p>
<p>插值表达式不能用于标签中</p>
<p>实例中的el一定要与插值表达式的盒子名称相同</p>
<p>插值表达式中的表达式一定要在data中定义</p>
<pre><code>&lt;body&gt;
  &lt;!-- 
    插值表达式
    语法：&#123;&#123;表达式&#125;&#125;
    用于将插入的地方到页面中进行渲染
   --&gt;
  &lt;div class=&quot;my&quot;&gt;
    &#123;&#123;mas&#125;&#125;
    &lt;!-- 结果为：tony --&gt;
    &#123;&#123;mas.toUpperCase()&#125;&#125;
    &lt;!-- 结果为：TONY --&gt;
    &#123;&#123;mas+'你好'&#125;&#125;
    &lt;!-- 结果为tony你好 --&gt;
  &lt;/div&gt;

  &lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue@2.7.16/dist/vue.js&quot;&gt;&lt;/script&gt;
  &lt;script&gt;
    const App = new Vue(&#123;
      el: &#39;.my&#39;,
      data: &#123;
        mas: &#39;tony&#39;
      &#125;

    &#125;)
  &lt;/script&gt;

&lt;/body&gt;
</code></pre>
<p>Vue指令（使用在标签中）</p>
<p>v-show、v-if</p>
<p>v-show与v-if都是用来设置内容显示或者隐藏的</p>
<p>相同点：可以设置内容显示与隐藏，结果为ture:显示，false:隐藏</p>
<p>不同点：v-show是用于频繁切换隐藏和显示的</p>
<pre><code>    v-if为要么隐藏要么显示，只为一种
</code></pre>
<p>v-if、v-else、v-else-if</p>
<p>这三个一般搭配着使用</p>
<pre><code>&lt;body&gt;

  &lt;div id=&quot;app&quot;&gt;
    &lt;!-- gender=1则显示男 --&gt;
    &lt;p v-if=&quot;gender===1&quot;&gt;性别：♂ 男&lt;/p&gt;
    &lt;!-- 否则显示女 --&gt;
    &lt;p v-else&gt;性别：♀ 女&lt;/p&gt;
    &lt;hr&gt;
    &lt;!-- 显示score&gt;=90对应的内容 --&gt;
    &lt;p v-if=&quot;score&gt;=90&quot;&gt;成绩评定A：奖励电脑一台&lt;/p&gt;

    &lt;!-- 显示80=&lt;score&lt;90对应的内容 --&gt;
    &lt;p v-else-if=&quot;score&gt;=80&quot;&gt;成绩评定B：奖励周末郊游&lt;/p&gt;

    &lt;!-- 显示60=&lt;score&lt;80对应的内容 --&gt;
    &lt;p v-else-if=&quot;score&gt;=60&quot;&gt;成绩评定C：奖励零食礼包&lt;/p&gt;
    
    &lt;!-- 显示0=&lt;score&lt;60对应的内容 --&gt;
    &lt;p v-else&gt;成绩评定D：惩罚一周不能玩手机&lt;/p&gt;
  &lt;/div&gt;

  &lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue@2.7.16/dist/vue.js&quot;&gt;&lt;/script&gt;
  &lt;script&gt;

    const app = new Vue(&#123;
      el: &#39;#app&#39;,
      data: &#123;
        // 给予固定数字
        gender: 1,
        score: 80
      &#125;
    &#125;)
  &lt;/script&gt;

&lt;/body&gt;
</code></pre>
<p>结果为：</p>
<p>性别：♂ 男</p>
<p>成绩评定B：奖励周末郊游</p>
<p>v-on</p>
<p>1.v-on:事件名&#x3D;”内联语句”（@事件名&#x3D;”内联函数”）</p>
<pre><code>&lt;body&gt;
    
  &lt;!-- 通过内联语句给按钮添加点击事件 --&gt;
  &lt;div class=&quot;app&quot;&gt;
    &lt;!-- v-on:事件名 --&gt;
    &lt;button v-on:click=&quot;count--&quot;&gt;-&lt;/button&gt;
    &#123;&#123;count&#125;&#125;
    &lt;!-- @事件名 --&gt;
    &lt;button @click=&quot;count++&quot;&gt;+&lt;/button&gt;
  &lt;/div&gt;

  &lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue@2.7.16/dist/vue.js&quot;&gt;&lt;/script&gt;
  &lt;script&gt;
    const app = new Vue(&#123;
      el: &#39;.app&#39;,
      data: &#123;
        count: 100,
      &#125;
    &#125;)
  &lt;/script&gt;
    
&lt;/body&gt;
</code></pre>
<p>2.v-on：事件名&#x3D;”methods中的函数名”  (@事件名&#x3D;”methods中的函数名”)</p>
<pre><code>&lt;body&gt;
  &lt;!-- 通过v-on：事件名=&quot;methods中的函数名&quot;添加点击事件  --&gt;
  &lt;div class=&quot;app&quot;&gt;
    &lt;!-- @事件名=&quot;methods中的函数名&quot; --&gt;
    &lt;button @click=&quot;fn&quot;&gt;切换按钮&lt;/button&gt;
    &lt;!-- 频繁切换用v-show(默认值设置为false，不显示) --&gt;
    &lt;p v-show=&quot;isShow&quot;&gt;黑马程序员&lt;/p&gt;
  &lt;/div&gt;

  &lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue@2.7.16/dist/vue.js&quot;&gt;&lt;/script&gt;
  &lt;script&gt;
    const app = new Vue(&#123;
      el: &#39;.app&#39;,
      data: &#123;
        isShow: false
      &#125;,
      methods: &#123;
        fn() &#123;
          // 使isShow的值取反
          this.isShow = !this.isShow
        &#125;
      &#125;
    &#125;)
  &lt;/script&gt;

&lt;/body&gt;
</code></pre>
<p>结果为：</p>
<p>点击“切换按钮”–&gt;显示“黑马程序员”</p>
<p>再点击“切换按钮”–&gt;隐藏“黑马程序员”</p>
<p>3.v-on：事件名&#x3D;”methods中的函数名（参数1，参数2….）”  (@事件名&#x3D;”methods中的函数名（参数1，参数2….）”)</p>
<pre><code>&lt;body&gt;
  &lt;!-- 通过v-on：事件名=&quot;methods中的函数名（参数1，参数2....）&quot;添加点击事件  --&gt;
  &lt;div id=&quot;app&quot;&gt;
    &lt;div class=&quot;box&quot;&gt;
      &lt;h3&gt;小黑自动售货机&lt;/h3&gt;
      &lt;!-- 通过函数传参 --&gt;
      &lt;button @click=&quot;fn(5)&quot;&gt;可乐5元&lt;/button&gt;
      &lt;button @click=&quot;fn(10)&quot;&gt;咖啡10元&lt;/button&gt;
    &lt;/div&gt;
    &lt;p&gt;银行卡余额：&#123;&#123;total&#125;&#125;元&lt;/p&gt;
  &lt;/div&gt;

  &lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue@2.7.16/dist/vue.js&quot;&gt;&lt;/script&gt;
  &lt;script&gt;
    const app = new Vue(&#123;
      el: &#39;#app&#39;,
      data: &#123;
        total: 100
      &#125;,
      methods: &#123;
        fn(price) &#123;
          this.total -= price
        &#125;
      &#125;
    &#125;)
  &lt;/script&gt;

&lt;/body&gt;
</code></pre>
<p>结果为：</p>
<p>点击可乐—&gt;余额减5</p>
<p>点击咖啡—&gt;余额减10</p>
<p>v-bind</p>
<p>v-bind动态的设置Html的标签属性</p>
<p>v-bind:属性名&#x3D;“表达式”（：属性名&#x3D;“表达式”）</p>
<pre><code>&lt;body&gt;

  &lt;div id=&quot;app&quot;&gt;
    &lt;!-- 用v-bind设置标签属性，也可省略为：属性名 --&gt;
    &lt;img v-bind:src=&quot;img&quot; :title=&quot;hellow&quot; alt=&quot;&quot;&gt;
  &lt;/div&gt;

  &lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue@2.7.16/dist/vue.js&quot;&gt;&lt;/script&gt;
  &lt;script&gt;
    const app = new Vue(&#123;
      el: &#39;#app&#39;,
      data: &#123;
        img: &#39;./imgs/10-01.png&#39;
      &#125;
    &#125;)
  &lt;/script&gt;

&lt;/body&gt;
</code></pre>
<p>v-bind对class的操作</p>
<pre><code>&lt;div&gt; :class = &quot;对象/数组&quot;&gt;这是一个div&lt;/div&gt;
</code></pre>
<p>对象语法：</p>
<p>当class动态绑定的是对象时，键就是类名，值就是布尔值，如果值是true，就有这个类，否则没有这个类(适用场景：一个类名，来回切换)</p>
<pre><code>&lt;div class=&quot;box&quot; :class=&quot;&#123; 类名1: 布尔值, 类名2: 布尔值 &#125;&quot;&gt;&lt;/div&gt;
</code></pre>
<p>数组语法：</p>
<p>当class动态绑定的是数组时 → 数组中所有的类，都会添加到盒子上，本质就是一个 class 列表( 使用场景:批量添加或删除类)</p>
<pre><code>&lt;div class=&quot;box&quot; :class=&quot;[ 类名1, 类名2, 类名3 ]&quot;&gt;&lt;/div&gt;
</code></pre>
<p>京东秒杀tab导航案例</p>
<pre><code>&lt;body&gt;

  &lt;div id=&quot;app&quot;&gt;
    &lt;ul&gt;
      &lt;!-- v-for遍历数组 --&gt;
      &lt;!-- 设置一个classIndex用来存储需要样式的下标 --&gt;
      &lt;!-- 判断样式是否为ture,为真将对应下标的标签显示光亮 --&gt;
      &lt;!-- 点击是将index值赋值为classIndex --&gt;
      &lt;li v-for=&quot;(item,index) in list&quot;&gt;&lt;a :class=&quot;&#123;active:index===classIndex&#125;&quot; href=&quot;#&quot;
          @click=&quot;classIndex=index&quot;&gt;&#123;&#123;item.name&#125;&#125;&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/div&gt;
  &lt;script src=&quot;./vue.js&quot;&gt;&lt;/script&gt;
  &lt;script&gt;
    const app = new Vue(&#123;
      el: &#39;#app&#39;,
      data: &#123;
        classIndex: 0,
        list: [
          &#123; id: 1, name: &#39;京东秒杀&#39; &#125;,
          &#123; id: 2, name: &#39;每日特价&#39; &#125;,
          &#123; id: 3, name: &#39;品类秒杀&#39; &#125;
        ]
      &#125;
    &#125;)
  &lt;/script&gt;
&lt;/body&gt;
</code></pre>
<p>v-bind对样式的操作</p>
<pre><code>&lt;div class=&quot;box&quot; :style=&quot;&#123; CSS属性名1: CSS属性值, CSS属性名2: CSS属性值 &#125;&quot;&gt;&lt;/div&gt;
</code></pre>
<p>进度条案例</p>
<pre><code>&lt;body&gt;
  &lt;div id=&quot;app&quot;&gt;
    &lt;div class=&quot;progress&quot;&gt;
      &lt;!-- 使用:style来设置样式，用percent来动态设置 --&gt;
      &lt;div class=&quot;inner&quot; :style=&quot;&#123;width:percent+&#39;%&#39;&#125;&quot;&gt;
        &lt;span&gt;&#123;&#123;percent&#125;&#125;%&lt;/span&gt;
      &lt;/div&gt;
    &lt;/div&gt;
    &lt;button @click=&quot;percent=25&quot;&gt;设置25%&lt;/button&gt;
    &lt;button @click=&quot;percent=50&quot;&gt;设置50%&lt;/button&gt;
    &lt;button @click=&quot;percent=75&quot;&gt;设置75%&lt;/button&gt;
    &lt;button @click=&quot;percent=100&quot;&gt;设置100%&lt;/button&gt;
  &lt;/div&gt;
  &lt;script src=&quot;../vue.js&quot;&gt;&lt;/script&gt;
  &lt;script&gt;
    const app = new Vue(&#123;
      el: &#39;#app&#39;,
      data: &#123;
        percent: 0
      &#125;
    &#125;)
  &lt;/script&gt;
&lt;/body&gt;
</code></pre>
<p>案例：图片切换—&gt;波仔学习之旅</p>
<pre><code>&lt;body&gt;
  &lt;!-- 案例：图片切换---波仔学习之旅
    1.显示的框架为上一页按钮，图片，下一张按钮
    2.图片应该放置到一个数组中，通过对应的index拿到图片
    3.给按钮添加点击事件，让index++/--即可
    4.点击上一页超过0隐藏按钮，点击下一页超过数组长度隐藏按钮
  --&gt;

  &lt;!-- 1.显示的框架为上一页按钮，图片，下一张按钮 --&gt;
  &lt;div class=&quot;app&quot;&gt;
    &lt;!-- 3.给按钮添加点击事件，让index++/--即可 --&gt;
    &lt;!-- 4.点击上一页超过0隐藏按钮 --&gt;
    &lt;button v-show=&quot;index&gt;0&quot; @click=&quot;index--&quot;&gt;上一页&lt;/button&gt;
    &lt;img :src=&quot;list[index]&quot; alt=&quot;&quot;&gt;
    &lt;!-- 4.点击下一页超过数组长度隐藏按钮 --&gt;
    &lt;button v-show=&quot;index&lt;list.length-1&quot; @click=&quot;index++&quot;&gt;下一页&lt;/button&gt;
  &lt;/div&gt;

  &lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue@2.7.16/dist/vue.js&quot;&gt;&lt;/script&gt;
  &lt;script&gt;
    const app = new Vue(&#123;
      el: &#39;.app&#39;,
      data: &#123;
        // 2.图片应该放置到一个数组中，通过对应的index拿到图片
        index: 0,
        list: [
          &#39;./imgs/10-01.png&#39;,
          &#39;./imgs/10-02.png&#39;,
          &#39;./imgs/11-00.gif&#39;,
          &#39;./imgs/11-01.gif&#39;,
          &#39;./imgs/11-02.gif&#39;,
          &#39;./imgs/11-03.gif&#39;,
        ]
      &#125;
    &#125;)
  &lt;/script&gt;

&lt;/body&gt;
</code></pre>
<p>v-for</p>
<p>基于数据渲染，可以渲染多个对象、数组、数字…</p>
<pre><code>&lt;body&gt;

  &lt;div id=&quot;app&quot;&gt;
    &lt;h3&gt;小黑水果店&lt;/h3&gt;
    &lt;ul&gt;
      &lt;!-- v-for进行循环数组的数据，格式为：v-for=&quot;(item,index) in 数组名&quot;【item为数组中的对象，index为数组的下标】 --&gt;
      &lt;li v-for=&quot;(item,index) in list&quot;&gt;&#123;&#123;item&#125;&#125;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/div&gt;

  &lt;script src=&quot;./vue.js&quot;&gt;&lt;/script&gt;
  &lt;script&gt;
    const app = new Vue(&#123;
      el: &#39;#app&#39;,
      data: &#123;
        list: [&#39;西瓜&#39;, &#39;苹果&#39;, &#39;鸭梨&#39;]
      &#125;
    &#125;)
  &lt;/script&gt;
&lt;/body&gt;
</code></pre>
<p>案例：小黑书架</p>
<pre><code>&lt;body&gt;
  &lt;!-- 
  1.基本渲染
  2.删除功能
 --&gt;
  &lt;div id=&quot;app&quot;&gt;
    &lt;h3&gt;小黑的书架&lt;/h3&gt;
    &lt;ul&gt;
      &lt;!-- 用v-for将数组渲染到li中  :key=&quot;唯一标识&quot;  --&gt;
      &lt;li v-for=&quot;(item,index) in booksList&quot; :key=&quot;index.id&quot;&gt;
        &lt;span&gt;&#123;&#123;item.name&#125;&#125;&lt;/span&gt;
        &lt;span&gt;&#123;&#123;item.author&#125;&#125;&lt;/span&gt;
        &lt;!-- 添加点击事件，删除del（传入需要删除的数据号） --&gt;
        &lt;button @click=&quot;del(item.id)&quot;&gt;删除&lt;/button&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/div&gt;
  &lt;script src=&quot;./vue.js&quot;&gt;&lt;/script&gt;
  &lt;script&gt;
    const app = new Vue(&#123;
      el: &#39;#app&#39;,
      data: &#123;
        booksList: [
          &#123; id: 1, name: &#39;《红楼梦》&#39;, author: &#39;曹雪芹&#39; &#125;,
          &#123; id: 2, name: &#39;《西游记》&#39;, author: &#39;吴承恩&#39; &#125;,
          &#123; id: 3, name: &#39;《水浒传》&#39;, author: &#39;施耐庵&#39; &#125;,
          &#123; id: 4, name: &#39;《三国演义》&#39;, author: &#39;罗贯中&#39; &#125;
        ]
      &#125;,
      methods: &#123;
        del(id) &#123;
          // 将传入的id号到数组中对应
          // 然后删除数据
          // 用filter：保留符合条件的数据，形成一个新的数组
          //将！id的数据留下即可实现删除效果 ,并赋值为原来的旧数组
          this.booksList = this.booksList.filter(item =&gt; item.id !== id)
        &#125;
      &#125;
    &#125;)
  &lt;/script&gt;
&lt;/body&gt;
</code></pre>
<p>v-model</p>
<p>数据和视图的双向绑定，用于获取或更改表单的数据</p>
<p>常见的表单元素都可以用 v-model 绑定关联  →  快速 获取 或 设置 表单元素的值</p>
<p>它会根据  控件类型 自动选取  正确的方法 来更新元素</p>
<pre><code>输入框  input:text   ——&gt; value
文本域  textarea	 ——&gt; value
复选框  input:checkbox  ——&gt; checked
单选框  input:radio   ——&gt; checked
下拉菜单 select    ——&gt; value
...
</code></pre>
<p>案例：小黑记事本</p>
<pre><code>&lt;body&gt;
  &lt;!-- 
  1.列表渲染
  2.删除功能
  3.添加功能
  4.底部统计和清空
 --&gt;
  &lt;!-- 主体区域 --&gt;
  &lt;section id=&quot;app&quot;&gt;
    &lt;!-- 输入框 --&gt;
    &lt;header class=&quot;header&quot;&gt;
      &lt;h1&gt;小黑记事本&lt;/h1&gt;
      &lt;input v-model=&quot;todoName&quot; placeholder=&quot;请输入任务&quot; class=&quot;new-todo&quot; /&gt;
      &lt;button @click=&quot;add&quot; class=&quot;add&quot;&gt;添加任务&lt;/button&gt;
    &lt;/header&gt;
    &lt;!-- 列表区域 --&gt;
    &lt;section class=&quot;main&quot;&gt;
      &lt;!--1.列表渲染=&gt; v-for--&gt;
      &lt;ul class=&quot;todo-list&quot;&gt;
        &lt;li class=&quot;todo&quot; v-for=&quot;(item,index) in list&quot; :key=&quot;item.id&quot;&gt;
          &lt;div class=&quot;view&quot;&gt;
            &lt;span class=&quot;index&quot;&gt;&#123;&#123;index+1&#125;&#125;&lt;/span&gt; &lt;label&gt;&#123;&#123;item.name&#125;&#125;&lt;/label&gt;
            &lt;button @click=&quot;del(item.id)&quot; class=&quot;destroy&quot;&gt;&lt;/button&gt;
          &lt;/div&gt;
        &lt;/li&gt;
      &lt;/ul&gt;
    &lt;/section&gt;
    &lt;!-- 统计和清空 --&gt;
    &lt;!-- list.length&gt;0时显示数据，list没有时隐藏最后一行 --&gt;
    &lt;footer class=&quot;footer&quot; v-show=&quot;list.length&gt;0&quot;&gt;
      &lt;!-- 统计 --&gt;
      &lt;span class=&quot;todo-count&quot;&gt;合 计:&lt;strong&gt; &#123;&#123;list.length&#125;&#125; &lt;/strong&gt;&lt;/span&gt;
      &lt;!-- 清空 --&gt;
      &lt;!-- 添加按钮，点击清楚===&gt;list=[] --&gt;
      &lt;button @click=&quot;list=[]&quot; class=&quot;clear-completed&quot;&gt;
        清空任务
      &lt;/button&gt;
    &lt;/footer&gt;
  &lt;/section&gt;

  &lt;!-- 底部 --&gt;
  &lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue/dist/vue.js&quot;&gt;&lt;/script&gt;
  &lt;script&gt;
    const app = new Vue(&#123;
      el: &#39;#app&#39;,
      data: &#123;
        toduName: &#39;&#39;,
        list: [
          &#123; id: 1, name: &#39;跑步&#39; &#125;,
          &#123; id: 2, name: &#39;睡觉一分钟&#39; &#125;
        ]
      &#125;,
      methods: &#123;
        del(id) &#123;
          // 2.删除功能 =&gt;filter(item=&gt;item.id!=id)
          this.list = this.list.filter(item =&gt; item.id !== id)
          // console.log(id);
        &#125;,
        add() &#123;
          // 判断输入的内容不能为空,trim()将文本掐头去尾后的值
          if (this.todoName.trim() === &#39;&#39;) &#123;
            // 提示
            alert(&#39;请不要输入空&#39;)
            return
          &#125;
          // 添加，往数组的最前面添加数据，用unshift(添加的内容要与数组格式相同)
          // id用函数自定义，name:则为v-model的todeName的双向绑定
          this.list.unshift(&#123;
            id: +new Date(),
            name: this.todeName
          &#125;)
          // 添加后，将输入的内容清空
          this.todoName = &#39;&#39;
        &#125;
      &#125;
    &#125;)

  &lt;/script&gt;
&lt;/body&gt;
</code></pre>
<p>第二天</p>
<p>指令修饰符</p>
<p>@key.enter</p>
<p>@key.enter&#x3D;”函数名”（可以与点击事件的函数名相同）即用户回车就可以进行函数相应的操作</p>
<p>v-model.trim&#x2F;v-model.number</p>
<p>v-model.trim&#x3D;”name” 监听name数据中的文本，将其去除前后空格</p>
<p>v-model.number&#x3D;”age” 将监听的age转换为数字的形式</p>
<p>@事件名.stop</p>
<p>阻止冒泡</p>
<p>@事件名.prevent</p>
<p>阻止默认行为</p>
<p>computed计算属性</p>
<p>由现有的数据通过计算得出新的属性的方法，可以使数据更加灵活</p>
<p>1.默认的计算属性，只能读取数据，不能修改</p>
<pre><code>&lt;body&gt;
  &lt;div id=&quot;app&quot;&gt;
    &lt;h3&gt;小黑的礼物清单&lt;/h3&gt;
    &lt;table&gt;
      &lt;tr&gt;
        &lt;th&gt;名字&lt;/th&gt;
        &lt;th&gt;数量&lt;/th&gt;
      &lt;/tr&gt;
      &lt;tr v-for=&quot;(item, index) in list&quot; :key=&quot;item.id&quot;&gt;
        &lt;td&gt;&#123;&#123; item.name &#125;&#125;&lt;/td&gt;
        &lt;td&gt;&#123;&#123; item.num &#125;&#125;个&lt;/td&gt;
      &lt;/tr&gt;
    &lt;/table&gt;

    &lt;!-- 目标：统计求和，求得礼物总数 --&gt;
    &lt;!-- 只需在此处插值函数名即可 --&gt;
    &lt;p&gt;礼物总数：&#123;&#123;total&#125;&#125; 个&lt;/p&gt;
  &lt;/div&gt;
  &lt;script src=&quot;../vue.js&quot;&gt;&lt;/script&gt;
  &lt;script&gt;
    const app = new Vue(&#123;
      el: &#39;#app&#39;,
      data: &#123;
        // 现有的数据
        list: [
          &#123; id: 1, name: &#39;篮球&#39;, num: 3 &#125;,
          &#123; id: 2, name: &#39;玩具&#39;, num: 2 &#125;,
          &#123; id: 3, name: &#39;铅笔&#39;, num: 5 &#125;,
        ]
      &#125;,
      computed: &#123;
        // 利用计算属性来进行计算
        total() &#123;
          // 利用reduce函数使数组自动连续相加
          return this.list.reduce((sum, item) =&gt; sum + item.num, 0)
        &#125;
      &#125;
    &#125;)
  &lt;/script&gt;
&lt;/body&gt;
</code></pre>
<p>2.计算属性的完整写法。即可读也可修改</p>
<pre><code>computed: &#123;
        计算属性名:&#123;
        //获取数据
          get()&#123;
            一段代码逻辑（计算逻辑）
            return 结果
          &#125;，
          //设置,修改数据
          set（修改的值）&#123;
            一段代码逻辑（修改逻辑）
          &#125;
        &#125;
      &#125;
</code></pre>
<p>例：改姓名</p>
<pre><code>&lt;body&gt;

  &lt;div id=&quot;app&quot;&gt;
    姓：&lt;input v-model=&quot;fist&quot; type=&quot;text&quot;&gt;&lt;br&gt;
    名：&lt;input v-model=&quot;last&quot; type=&quot;text&quot;&gt;&lt;br&gt;
    &lt;p&gt;姓名：&#123;&#123;all&#125;&#125;&lt;/p&gt;
    &lt;!-- 给按钮添加点击事件 --&gt;
    &lt;button @click=&quot;change&quot;&gt;修改姓名&lt;/button&gt;
  &lt;/div&gt;
  &lt;script src=&quot;../vue.js&quot;&gt;&lt;/script&gt;
  &lt;script&gt;
    const app = new Vue(&#123;
      el: &#39;#app&#39;,
      data: &#123;
        fist: &#39;&#39;,
        last: &#39;&#39;
      &#125;,
      computed: &#123;
        all: &#123;
          get() &#123;
            return this.fist + this.last
          &#125;,
          set(value) &#123;
            // value则是姓名中的值
            // 使用slice函数截取字符串=&gt;slice(截取位置下标，截取个数)，如需截取到最后，截取个数可省略
            this.fist = value.slice(0, 1)
            this.last = value.slice(1)
          &#125;
        &#125;
      &#125;,
      methods: &#123;
        change() &#123;
          return this.all = &#39;余晓晓&#39;
        &#125;
      &#125;
    &#125;)
  &lt;/script&gt;
&lt;/body&gt;
</code></pre>
<p>computed和methods的区别</p>
<p>computed：封装一段对于数据的处理，重在求得一个结果</p>
<pre><code>作为属性，直接使用--&gt;this.计算属性      &#123;&#123;计算属性&#125;&#125;
</code></pre>
<p>methods：给实例一个方法，调用以处理业务逻辑</p>
<pre><code>作为方法，需要调用--&gt;this.方法名（）    &#123;&#123;方法名（）&#125;&#125;      @事件名=“方法名”
</code></pre>
<p>案例：成绩案例</p>
<pre><code>&lt;body&gt;
  &lt;!-- 
      1.渲染数据
      2.删除功能
      3.添加功能
      4.总分，平均分
     --&gt;
  &lt;div id=&quot;app&quot; class=&quot;score-case&quot;&gt;
    &lt;div class=&quot;table&quot;&gt;
      &lt;table&gt;
        &lt;thead&gt;
          &lt;tr&gt;
            &lt;th&gt;编号&lt;/th&gt;
            &lt;th&gt;科目&lt;/th&gt;
            &lt;th&gt;成绩&lt;/th&gt;
            &lt;th&gt;操作&lt;/th&gt;
          &lt;/tr&gt;
        &lt;/thead&gt;
        &lt;!-- 使用v-if切换数据模块和暂无数据模块 --&gt;
        &lt;tbody v-if=&quot;list.length&gt;0&quot;&gt;
          &lt;!-- 利用v-for将数据渲染到页面中 --&gt;
          &lt;tr v-for=&quot;(item,index) in list&quot; :key=&quot;item.id&quot;&gt;
            &lt;td&gt;&#123;&#123;index+1&#125;&#125;&lt;/td&gt;
            &lt;td&gt;&#123;&#123;item.subject&#125;&#125;&lt;/td&gt;
            &lt;!-- 用v-bind动态设置样式 --&gt;
            &lt;td :class=&quot;&#123;red:item.score&lt;60&#125;&quot;&gt;&#123;&#123;item.score&#125;&#125;&lt;/td&gt;
            &lt;!-- 给删除添加点击事件 --&gt;
            &lt;td @click=&quot;del(item.id)&quot;&gt;&lt;a href=&quot;#&quot;&gt;删除&lt;/a&gt;&lt;/td&gt;
          &lt;/tr&gt;
        &lt;/tbody&gt;
        &lt;tbody v-else&gt;
          &lt;tr&gt;
            &lt;td colspan=&quot;5&quot;&gt;
              &lt;span class=&quot;none&quot;&gt;暂无数据&lt;/span&gt;
            &lt;/td&gt;
          &lt;/tr&gt;
        &lt;/tbody&gt;
        &lt;!-- 当没有数据时，隐藏下面的总和和平均分的显示，v-show --&gt;
        &lt;tfoot v-show=&quot;list.length&gt;0&quot;&gt;
          &lt;tr&gt;
            &lt;td colspan=&quot;5&quot;&gt;
              &lt;!-- 总分和平均数可以利用一个computed函数进行封装起来 --&gt;
              &lt;span&gt;总分：&#123;&#123;total&#125;&#125;&lt;/span&gt;
              &lt;span style=&quot;margin-left: 50px&quot;&gt;平均分：&#123;&#123;average&#125;&#125;&lt;/span&gt;
            &lt;/td&gt;
          &lt;/tr&gt;
        &lt;/tfoot&gt;
      &lt;/table&gt;
    &lt;/div&gt;
    &lt;div class=&quot;form&quot;&gt;
      &lt;!-- 利用v-model进行数据双向绑定--&gt;
      &lt;div class=&quot;form-item&quot;&gt;
        &lt;div class=&quot;label&quot;&gt;科目：&lt;/div&gt;
        &lt;div class=&quot;input&quot;&gt;
          &lt;input v-model.trim=&quot;subject&quot; type=&quot;text&quot; placeholder=&quot;请输入科目&quot; /&gt;
        &lt;/div&gt;
      &lt;/div&gt;
      &lt;div class=&quot;form-item&quot;&gt;
        &lt;div class=&quot;label&quot;&gt;分数：&lt;/div&gt;
        &lt;div class=&quot;input&quot;&gt;
          &lt;input v-model.number=&quot;score&quot; type=&quot;text&quot; placeholder=&quot;请输入分数&quot; /&gt;
        &lt;/div&gt;
      &lt;/div&gt;
      &lt;div class=&quot;form-item&quot;&gt;
        &lt;div class=&quot;label&quot;&gt;&lt;/div&gt;
        &lt;div class=&quot;input&quot;&gt;
          &lt;!-- 给添加按钮添加点击事件  --&gt;
          &lt;button @click=&quot;add&quot; class=&quot;submit&quot;&gt;添加&lt;/button&gt;
        &lt;/div&gt;
      &lt;/div&gt;
    &lt;/div&gt;
  &lt;/div&gt;
  &lt;script src=&quot;../vue.js&quot;&gt;&lt;/script&gt;

  &lt;script&gt;
    const app = new Vue(&#123;
      el: &#39;#app&#39;,
      data: &#123;
        list: [
          &#123; id: 1, subject: &#39;语文&#39;, score: 20 &#125;,
          &#123; id: 7, subject: &#39;数学&#39;, score: 100 &#125;,
          &#123; id: 12, subject: &#39;英语&#39;, score: 70 &#125;,
        ],
        subject: &#39;&#39;,
        score: &#39;&#39;
      &#125;,
      methods: &#123;
        // 删除方法的代码逻辑语块
        del(id) &#123;
          // 利用filter函数
          this.list = this.list.filter(item =&gt; item.id != id)
        &#125;,
        add() &#123;
          // 添加一个判断，科目是否为空，分数是否为数字
          if (this.subject === &#39;&#39; &amp;&amp; (this.score === &#39;&#39;)) &#123;
            alert(&#39;请输入正确的文本和数字&#39;)
            return
          &#125;
          // 将获取到的信息添加到数组中,利用了unshift()将数据添加到数组的第一位
          this.list.unshift(&#123;
            id: +new Date(),
            subject: this.subject,
            score: this.score
          &#125;)
          // 添加后，将文本框默认的输入清空
          this.subject = &#39;&#39;
          this.score = &#39;&#39;
        &#125;
      &#125;,
      computed: &#123;
        // 计算总分,利用reduce函数
        total() &#123;
          return this.list.reduce((sum, item) =&gt; sum + item.score, 0)
        &#125;,
        // 计算平均分
        average() &#123;
          // 计算后，小数点保留两位小数
          return (this.total / this.list.length).toFixed(2)
        &#125;
      &#125;
    &#125;)
  &lt;/script&gt;
&lt;/body&gt;
</code></pre>
<p>watch监听器</p>
<p>监视数据变化，执行一些业务逻辑或异步操作</p>
<p>简单写法</p>
<p>简单类型数据直接监听，对一个属性进行监听</p>
<pre><code>data: &#123; 
    //words以及由v-model进行双向绑定
  words: &#39;苹果&#39;,
  obj: &#123;
    words: &#39;苹果&#39;
  &#125;
&#125;,

watch: &#123;
  // 该方法会在数据变化时，触发执行
  //一般使用新值，旧值可以省略不计
  数据属性名 (newValue, oldValue) &#123;
    一些业务逻辑 或 异步操作。 
  &#125;,
  &#39;对象.属性名&#39; (newValue, oldValue) &#123;
    一些业务逻辑 或 异步操作。 
  &#125;
&#125;
</code></pre>
<p>案例：翻译器</p>
<pre><code>  &lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue@2/dist/vue.js&quot;&gt;&lt;/script&gt;
  &lt;script src=&quot;https://cdn.jsdelivr.net/npm/axios/dist/axios.min.js&quot;&gt;&lt;/script&gt;
  &lt;script&gt;
    // 接口地址：https://applet-base-api-t.itheima.net/api/translate
    // 请求方式：get
    // 请求参数：
    // （1）words：需要被翻译的文本（必传）
    // （2）lang： 需要被翻译成的语言（可选）默认值-意大利
    // -----------------------------------------------
    // 因为翻译是需要等待用户输入完整的字符时间，所以需要防抖（给予用户一个时间，让其输入完整的字符，就需要添加一个定时器）
    const app = new Vue(&#123;
      el: &#39;#app&#39;,
      data: &#123;
        obj: &#123;
          words: &#39;&#39;
        &#125;,
        result: &#39;&#39;,
        timer: null
      &#125;,
      // 监听words值，并通过axios到接口中查询数据，通过异步传输（async,await)将结果渲染到页面中
      watch: &#123;
        // 函数名不能识别符号，所以要用&#39;&#39;括起来
        &#39;obj.words&#39;(newValue) &#123;
          // 先关闭定时器，再开启定时器
          clearTimeout(this.timer)
          // 因为翻译是需要等待用户输入完整的字符时间，所以需要防抖（给予用户一个时间，让其输入完整的字符，就需要添加一个定时器）
          this.timer = setTimeout(async () =&gt; &#123;
            const res = await axios(&#123;
              url: &#39;https://applet-base-api-t.itheima.net/api/translate&#39;,
              params: &#123;
                // 向接口传输需要查询的值
                words: newValue
              &#125;
            &#125;)
            // res.data.data为查询后的结果
            // console.log(res.data.data);
            // 将得到的值渲染到页面中
            this.result = res.data.data
          &#125;, 300)

        &#125;
      &#125;
    &#125;)
  &lt;/script&gt;
</code></pre>
<p>完整写法</p>
<p>通过，输入语言和切换语种两个属性进行翻译，深度监视</p>
<p>案例：翻译器</p>
<pre><code>&lt;body&gt;
  &lt;div id=&quot;app&quot;&gt;
    &lt;!-- 条件选择框 --&gt;
    &lt;div class=&quot;query&quot;&gt;
      &lt;span&gt;翻译成的语言：&lt;/span&gt;
      &lt;select v-model=&quot;obj.lang&quot;&gt;
        &lt;!-- 默认语言为意大利 --&gt;
        &lt;option value=&quot;italy&quot;&gt;意大利&lt;/option&gt;
        &lt;option value=&quot;english&quot;&gt;英语&lt;/option&gt;
        &lt;option value=&quot;german&quot;&gt;德语&lt;/option&gt;
      &lt;/select&gt;
    &lt;/div&gt;

    &lt;!-- 翻译框 --&gt;
    &lt;div class=&quot;box&quot;&gt;
      &lt;div class=&quot;input-wrap&quot;&gt;
        &lt;textarea v-model=&quot;obj.words&quot;&gt;&lt;/textarea&gt;
        &lt;span&gt;&lt;i&gt;⌨️&lt;/i&gt;文档翻译&lt;/span&gt;
      &lt;/div&gt;
      &lt;div class=&quot;output-wrap&quot;&gt;
        &lt;div class=&quot;transbox&quot;&gt;&#123;&#123;result&#125;&#125;&lt;/div&gt;
      &lt;/div&gt;
    &lt;/div&gt;
  &lt;/div&gt;
  &lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue@2/dist/vue.js&quot;&gt;&lt;/script&gt;
  &lt;script src=&quot;https://cdn.jsdelivr.net/npm/axios/dist/axios.min.js&quot;&gt;&lt;/script&gt;
  &lt;script&gt;
    // 接口地址：https://applet-base-api-t.itheima.net/api/translate
    // 请求方式：get
    // 请求参数：
    // （1）words：需要被翻译的文本（必传）
    // （2）lang： 需要被翻译成的语言（可选）默认值-意大利
    // -----------------------------------------------
    // 因为翻译是需要等待用户输入完整的字符时间，所以需要防抖（给予用户一个时间，让其输入完整的字符，就需要添加一个定时器）
    const app = new Vue(&#123;
      el: &#39;#app&#39;,
      data: &#123;
        obj: &#123;
          words: &#39;你好&#39;,
          lang: &#39;italy&#39;
        &#125;,
        result: &#39;&#39;,
        timer: null
      &#125;,
      // watch的完整写法
      watch: &#123;
        // 监听两个属性值时，则需要用对象将其包裹起来
        obj: &#123;
          deep: true,//深度监视，即对所有属性进行监视
          immediate: true,//立即执行，即一进入页面handler就执行一次
          // newValue是个对象，里面包含words的值和lang的值
          handler(newValue) &#123;
            clearTimeout(this.timer)
            // 防抖
            this.timer = setTimeout(async () =&gt; &#123;
              const res = await axios(&#123;
                url: &#39;https://applet-base-api-t.itheima.net/api/translate&#39;,
                params: newValue  //直接传入newValue即可，是个对象
              &#125;)
              // 将查询的结果渲染到页面中
              this.result = res.data.data
            &#125;, 300)
          &#125;
        &#125;
      &#125;
    &#125;)
  &lt;/script&gt;
&lt;/body&gt;
</code></pre>
<p>案例：水果购物车</p>
<pre><code>&lt;body&gt;
    &lt;div class=&quot;app-container&quot; id=&quot;app&quot;&gt;
      &lt;!-- 顶部banner --&gt;
      &lt;div class=&quot;banner-box&quot;&gt;&lt;img src=&quot;http://autumnfish.cn/static/fruit.jpg&quot; alt=&quot;&quot; /&gt;&lt;/div&gt;
      &lt;!-- 面包屑 --&gt;
      &lt;div class=&quot;breadcrumb&quot;&gt;
        &lt;span&gt;🏠&lt;/span&gt;
        /
        &lt;span&gt;购物车&lt;/span&gt;
      &lt;/div&gt;
      &lt;!-- 购物车主体 --&gt;
      &lt;div class=&quot;main&quot; v-if=&quot;fruitList.length &gt; 0&quot;&gt;
        &lt;div class=&quot;table&quot;&gt;
          &lt;!-- 头部 --&gt;
          &lt;div class=&quot;thead&quot;&gt;
            &lt;div class=&quot;tr&quot;&gt;
              &lt;div class=&quot;th&quot;&gt;选中&lt;/div&gt;
              &lt;div class=&quot;th th-pic&quot;&gt;图片&lt;/div&gt;
              &lt;div class=&quot;th&quot;&gt;单价&lt;/div&gt;
              &lt;div class=&quot;th num-th&quot;&gt;个数&lt;/div&gt;
              &lt;div class=&quot;th&quot;&gt;小计&lt;/div&gt;
              &lt;div class=&quot;th&quot;&gt;操作&lt;/div&gt;
            &lt;/div&gt;
          &lt;/div&gt;
          &lt;!-- 身体 --&gt;
          &lt;div class=&quot;tbody&quot;&gt;
            &lt;div v-for=&quot;(item, index) in fruitList&quot; :key=&quot;item.id&quot; class=&quot;tr&quot; :class=&quot;&#123; active: item.isChecked &#125;&quot;&gt;
              &lt;div class=&quot;td&quot;&gt;&lt;input type=&quot;checkbox&quot; v-model=&quot;item.isChecked&quot; /&gt;&lt;/div&gt;
              &lt;div class=&quot;td&quot;&gt;&lt;img :src=&quot;item.icon&quot; alt=&quot;&quot; /&gt;&lt;/div&gt;
              &lt;div class=&quot;td&quot;&gt;&#123;&#123; item.price &#125;&#125;&lt;/div&gt;
              &lt;div class=&quot;td&quot;&gt;
                &lt;div class=&quot;my-input-number&quot;&gt;
                  &lt;button :disabled=&quot;item.num &lt;= 1&quot; class=&quot;decrease&quot; @click=&quot;sub(item.id)&quot;&gt; - &lt;/button&gt;
                  &lt;span class=&quot;my-input__inner&quot;&gt;&#123;&#123; item.num &#125;&#125;&lt;/span&gt;
                  &lt;button class=&quot;increase&quot; @click=&quot;add(item.id)&quot;&gt; + &lt;/button&gt;
                &lt;/div&gt;
              &lt;/div&gt;
              &lt;div class=&quot;td&quot;&gt;&#123;&#123; item.num * item.price &#125;&#125;&lt;/div&gt;
              &lt;div class=&quot;td&quot;&gt;&lt;button @click=&quot;del(item.id)&quot;&gt;删除&lt;/button&gt;&lt;/div&gt;
            &lt;/div&gt;
          &lt;/div&gt;
        &lt;/div&gt;
        &lt;!-- 底部 --&gt;
        &lt;div class=&quot;bottom&quot;&gt;
          &lt;!-- 全选 --&gt;
          &lt;label class=&quot;check-all&quot;&gt;
            &lt;input type=&quot;checkbox&quot; v-model=&quot;isAll&quot;/&gt;
            全选
          &lt;/label&gt;
          &lt;div class=&quot;right-box&quot;&gt;
            &lt;!-- 所有商品总价 --&gt;
            &lt;span class=&quot;price-box&quot;&gt;总价&amp;nbsp;&amp;nbsp;:&amp;nbsp;&amp;nbsp;¥&amp;nbsp;&lt;span class=&quot;price&quot;&gt;&#123;&#123; totalPrice &#125;&#125;&lt;/span&gt;&lt;/span&gt;
            &lt;!-- 结算按钮 --&gt;
            &lt;button class=&quot;pay&quot;&gt;结算( &#123;&#123; totalCount &#125;&#125; )&lt;/button&gt;
          &lt;/div&gt;
        &lt;/div&gt;
      &lt;/div&gt;
      &lt;!-- 空车 --&gt;
      &lt;div class=&quot;empty&quot; v-else&gt;🛒空空如也&lt;/div&gt;
    &lt;/div&gt;
    &lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue@2/dist/vue.js&quot;&gt;&lt;/script&gt;
    &lt;script&gt;
      const defaultArr = [
            &#123;
              id: 1,
              icon: &#39;http://autumnfish.cn/static/火龙果.png&#39;,
              isChecked: true,
              num: 2,
              price: 6,
            &#125;,
            &#123;
              id: 2,
              icon: &#39;http://autumnfish.cn/static/荔枝.png&#39;,
              isChecked: false,
              num: 7,
              price: 20,
            &#125;,
            &#123;
              id: 3,
              icon: &#39;http://autumnfish.cn/static/榴莲.png&#39;,
              isChecked: false,
              num: 3,
              price: 40,
            &#125;,
            &#123;
              id: 4,
              icon: &#39;http://autumnfish.cn/static/鸭梨.png&#39;,
              isChecked: true,
              num: 10,
              price: 3,
            &#125;,
            &#123;
              id: 5,
              icon: &#39;http://autumnfish.cn/static/樱桃.png&#39;,
              isChecked: false,
              num: 20,
              price: 34,
            &#125;,
          ]
      const app = new Vue(&#123;
        el: &#39;#app&#39;,
        data: &#123;
          // 水果列表
          fruitList: JSON.parse(localStorage.getItem(&#39;list&#39;)) || defaultArr,
        &#125;,
        computed: &#123;
          // 默认计算属性：只能获取不能设置，要设置需要写完整写法
          // isAll () &#123;
          //   // 必须所有的小选框都选中，全选按钮才选中 → every
          //   return this.fruitList.every(item =&gt; item.isChecked)
          // &#125;
          
          // 完整写法 = get + set
          isAll: &#123;
            get () &#123;
              return this.fruitList.every(item =&gt; item.isChecked)
            &#125;,
            set (value) &#123;
              // 基于拿到的布尔值，要让所有的小选框 同步状态
              this.fruitList.forEach(item =&gt; item.isChecked = value)
            &#125;
          &#125;,
          // 统计选中的总数 reduce
          totalCount () &#123;
            return this.fruitList.reduce((sum, item) =&gt; &#123;
              if (item.isChecked) &#123;
                // 选中 → 需要累加
                return sum + item.num
              &#125; else &#123;
                // 没选中 → 不需要累加
                return sum
              &#125;
            &#125;, 0)
          &#125;,
          // 总计选中的总价 num * price
          totalPrice () &#123;
            return this.fruitList.reduce((sum, item) =&gt; &#123;
              if (item.isChecked) &#123;
                return sum + item.num * item.price
              &#125; else &#123;
                return sum
              &#125;
            &#125;, 0)
          &#125;
        &#125;,
        methods: &#123;
          del (id) &#123;
            this.fruitList = this.fruitList.filter(item =&gt; item.id !== id)
          &#125;,
          add (id) &#123;
            // 1. 根据 id 找到数组中的对应项 → find
            const fruit = this.fruitList.find(item =&gt; item.id === id)
            // 2. 操作 num 数量
            fruit.num++
          &#125;,
          sub (id) &#123;
            // 1. 根据 id 找到数组中的对应项 → find
            const fruit = this.fruitList.find(item =&gt; item.id === id)
            // 2. 操作 num 数量
            fruit.num--
          &#125;
        &#125;,
        watch: &#123;
          fruitList: &#123;
            deep: true,
            handler (newValue) &#123;
              // 需要将变化后的 newValue 存入本地 （转JSON）
              localStorage.setItem(&#39;list&#39;, JSON.stringify(newValue))
            &#125;
          &#125;
        &#125;
      &#125;)
    &lt;/script&gt;
  &lt;/body&gt;
</code></pre>
<p>第三天</p>
<p>生命周期</p>
<p>Vue生命周期：就是一个Vue实例从创建 到 销毁 的整个过程。</p>
<p>生命周期四个阶段：① 创建 ② 挂载 ③ 更新 ④ 销毁</p>
<p>1.创建阶段：创建响应式数据</p>
<p>2.挂载阶段：渲染模板</p>
<p>3.更新阶段：修改数据，更新视图</p>
<p>4.销毁阶段：销毁Vue实例</p>
<p>Vue生命周期钩子</p>
<p>Vue生命周期过程中，会自动运行一些函数，被称为【生命周期钩子】→  让开发者可以在【特定阶段】运行自己的代码</p>
<p>案例：小黑记账清单(接口，echarts)</p>
<ul>
<li>功能需求：<ul>
<li><ol>
<li>基本渲染<br>在vue创建时到接口中获取数据   created（）<br>将获取到的数据渲染到页面中   v-for<br>消费总计利用计算属性获取   computed</li>
</ol>
</li>
<li><ol>
<li>添加功能<br>获取表单数据   v-model<br>给按钮添加一个点击事件<br>将数据传入给接口<br>再重新渲染</li>
</ol>
</li>
<li><ol>
<li>删除功能<br>给删除添加点击事件<br>通过id将接口中的数据删除<br>重新渲染</li>
</ol>
</li>
<li><ol>
<li>饼图渲染，echarts<br>饼图需要在获得数据后立即渲染   mounted()<br>到echarts官网中选择样式<br>在渲染函数中，getlist中单独将图表中的数据进行替换</li>
</ol>
<body>
  <div id="app">
    <div class="contain">
      <!-- 左侧列表 -->
      <div class="list-box">

<pre><code>    &lt;!-- 添加资产 --&gt;
    &lt;form class=&quot;my-form&quot;&gt;
      &lt;input type=&quot;text&quot; class=&quot;form-control&quot; placeholder=&quot;消费名称&quot; v-model=&quot;name&quot; /&gt;
      &lt;input type=&quot;text&quot; class=&quot;form-control&quot; placeholder=&quot;消费价格&quot; v-model=&quot;price&quot; /&gt;
      &lt;button @click=&quot;add&quot; type=&quot;button&quot; class=&quot;btn btn-primary&quot;&gt;添加账单&lt;/button&gt;
    &lt;/form&gt;

    &lt;table class=&quot;table table-hover&quot;&gt;
      &lt;thead&gt;
        &lt;tr&gt;
          &lt;th&gt;编号&lt;/th&gt;
          &lt;th&gt;消费名称&lt;/th&gt;
          &lt;th&gt;消费价格&lt;/th&gt;
          &lt;th&gt;操作&lt;/th&gt;
        &lt;/tr&gt;
      &lt;/thead&gt;
      &lt;tbody&gt;
        &lt;!-- 将list的数组用v-for进行渲染 --&gt;
        &lt;tr v-for=&quot;(item,index) in list&quot; :key=&quot;item.id&quot;&gt;
          &lt;td&gt;&#123;&#123;index +1&#125;&#125;&lt;/td&gt;
          &lt;td&gt;&#123;&#123;item.name&#125;&#125;&lt;/td&gt;
          &lt;td&gt;&#123;&#123;item.price.toFixed(2)&#125;&#125;&lt;/td&gt;
          &lt;td @click=&quot;del(item.id)&quot;&gt;&lt;a href=&quot;javascript:;&quot;&gt;删除&lt;/a&gt;&lt;/td&gt;
        &lt;/tr&gt;
      &lt;/tbody&gt;
      &lt;tfoot&gt;
        &lt;tr&gt;
          &lt;td colspan=&quot;4&quot;&gt;消费总计：&#123;&#123;total&#125;&#125;&lt;/td&gt;
        &lt;/tr&gt;
      &lt;/tfoot&gt;
    &lt;/table&gt;
  &lt;/div&gt;

  &lt;!-- 右侧图表 --&gt;
  &lt;div class=&quot;echarts-box&quot; id=&quot;main&quot;&gt;&lt;/div&gt;
&lt;/div&gt;
</code></pre>
  </div>
  <script src="../echarts.min.js"></script>
  <script src="../vue.js"></script>
  <script src="../axios.js"></script>
  <script>
    /**
     * 接口文档地址：
     * https://www.apifox.cn/apidoc/shared-24459455-ebb1-4fdc-8df8-0aff8dc317a8/api-53371058
     * 
     * 功能需求：
     * 1. 基本渲染
          在vue创建时到接口中获取数据   created（）
          将获取到的数据渲染到页面中   v-for
          消费总计利用计算属性获取   computed
     * 2. 添加功能
          获取表单数据   v-model
          给按钮添加一个点击事件
          将数据传入给接口
          再重新渲染
     * 3. 删除功能
          给删除添加点击事件
          通过id将接口中的数据删除
          重新渲染
     * 4. 饼图渲染
          饼图需要在获得数据后立即渲染   mounted()
          到echarts官网中选择样式
          将图表中的数据进行替换
     */
    const app = new Vue({
      el: '#app',
      data: {
        list: [],
        name: '',
        price: ''
      },
      created() {
        this.getList()
      },
      mounted() {
        // 初始化echarts实例
        // 在前面添加this，可以使后续使用更加方便
        this.myChart = echarts.init(document.getElementById('main'));
        this.myChart.setOption({
          title: {
            text: '消费统计图',
            left: 'center'
          },
          tooltip: {
            trigger: 'item'
          },
          legend: {
            orient: 'vertical',
            left: 'left'
          },
          series: [
            {
              name: '消费占比',
              type: 'pie',
              radius: '50%',
              data: [],//需要实时更新的数据，直接在渲染函数getlist中设置
              emphasis: {
                itemStyle: {
                  shadowBlur: 10,
                  shadowOffsetX: 0,
                  shadowColor: 'rgba(0, 0, 0, 0.5)'
                }
              }
            }
          ]
        })
      },
      computed: {
        total() {
          return this.list.reduce((sum, item) => sum + item.price, 0)
        }
      },
      methods: {
        // 基本渲染函数
        async getList() {
          // 到接口中获取数据
          // axios异步请求的简化
          const res = await axios.get('https://applet-base-api-t.itheima.net/bill', {
            // get==>params用对象的形式传需要获取参数
            params: {
              creator: '张三'
            }
          })
          // console.log(res.data.data);
          // 将接口中的数据赋值给data中的list
          this.list = res.data.data
          // console.log(this.list);
          // 拿到数据后，实时更新饼图显示
          this.myChart.setOption({
            // 需要实时更新的数据
            series: [
              {
                // 原饼图的格式
                // data: [
                //   { value: 1048, name: 'Search Engine' },
                //   { value: 735, name: 'Direct' },
                //   { value: 580, name: 'Email' },
                //   { value: 484, name: 'Union Ads' },
                //   { value: 300, name: 'Video Ads' }
                // ],
                //利用map将数据重新构建，取出相应的数据，以对象的形式生成新的数组
                data: this.list.map(item => ({ value: item.price, name: item.name }))
              }
            ]
          })
        },
        // 添加方法
        async add() {
          // console.log(this.name, this.price);
          // post对应的是data，传输数据给接口，可以省略data。直接以对象的形式传输给接口
          const res = await axios.post('https://applet-base-api-t.itheima.net/bill', {
            creator: '张三',
            name: this.name,
            price: this.price
          })
          this.name = ''
          this.price = ''
          // 再重新进行渲染
          this.getList()
        },
        // 删除功能
        async del(id) {
          // console.log(id);
          const res = await axios.delete(`https://applet-base-api-t.itheima.net/bill/${id}`)
          // console.log(res);
          this.getList()
        }
      }
    })
  </script>
</body></li>
</ul>
</li>
</ul>
<p>通过脚手架创建项目</p>
<ol>
<li>main.js  入口文件</li>
<li>App.vue  App根组件 </li>
<li>index.html 模板文件</li>
</ol>
<p>核心步骤</p>
<p>1.安装脚手架（只需安装一次即可） yarn global add @vue&#x2F;cli 或者 npm i @vue&#x2F;cli -g</p>
<p>2.查看vue&#x2F;cli版本： vue –version</p>
<p>3.在根目录下，打开cmd，创建vue文件。(vue create 项目名)</p>
<pre><code>vue create yxx
</code></pre>
<p>4.先进入项目中，cd 项目名</p>
<pre><code>cd yxx
</code></pre>
<p>5.后运行vue官网页面，有的是serve，有的是dev，具体需要到package.json中的scripts对象中查看</p>
<pre><code>npm run serve
</code></pre>
<p>创建一个计数器</p>
<pre><code>&lt;template&gt;
  &lt;!-- 页面显示的内容 --&gt;
  &lt;!-- 只能含有一个大的App盒子，剩余的盒子都只能在App中创建 --&gt;
  &lt;div class=&quot;App&quot;&gt;
    &lt;button @click=&quot;sbu()&quot;&gt;-&lt;/button&gt;
    &#123;&#123; count &#125;&#125;
    &lt;button @click=&quot;add()&quot;&gt;+&lt;/button&gt;
  &lt;/div&gt;
&lt;/template&gt;

&lt;script&gt;
export default &#123;
  // 固定格式，需要数据就写在return中
data()&#123;
  return&#123;
    count:9
  &#125;
&#125;,
methods:&#123;
  // sbu（）减方法
  sbu()&#123;
    // 小于0就不能再减
    if(this.count&lt;=0)
    &#123;
      // 小于0退出
      return
    &#125;
    // 数据--
    this.count --
  &#125;,
  // add()加方法
  add()&#123;
    // 数据++
    this.count ++
  &#125;
&#125;
&#125;
&lt;/script&gt;

&lt;style&gt;
/* 内容样式 */
.App&#123;
  background-color: pink;
  width: 200px;
  height: 100px;
  margin: 0 auto;
&#125;
.App button&#123;
  background-color:bisque;
  width: 50px;
  height: 50px;
  margin: 0 auto;
  font-size: 20px;
&#125;
&lt;/style&gt;
</code></pre>
<p>组件化开发</p>
<pre><code> 组件化：一个页面可以拆分成一个个组件，每个组件有着自己独立的结构、样式、行为。

 好处：便于维护，利于复用 → 提升开发效率。

 组件分类：普通组件、根组件。
</code></pre>
<p>组件构成</p>
<ul>
<li>三部分构成<ul>
<li>template：结构 （有且只能一个根元素）</li>
<li>script:   js逻辑 </li>
<li>style： 样式 (可支持less，需要装包)</li>
</ul>
</li>
<li>让组件支持less<br>（1） style标签，lang&#x3D;”less” 开启less功能<br>（2） 装包: yarn add less less-loader -D 或者npm i less less-loader -D</li>
</ul>
<p>普通组件的注册使用-局部注册</p>
<p>特点：</p>
<pre><code>只能在注册的组件内使用（在components中设置组件页面，在App.vue中引入的插入渲染位置）
</code></pre>
<p>步骤：</p>
<ol>
<li>创建.vue文件（三个组成部分）</li>
<li>在使用的组件内先导入再注册，最后使用</li>
</ol>
<p>使用方式：</p>
<pre><code>当成html标签使用即可  &lt;组件名&gt;&lt;/组件名&gt;
</code></pre>
<p>注意：</p>
<pre><code>组件名规范 —&gt; 大驼峰命名法， 如 HmHeader
</code></pre>
<p>案例：局部组件</p>
<p>1.先在App.vue根组件中设置一个大的框架以及颜色</p>
<p>2.分别在compounents文件夹下创建HmHeader.vue、HmMain.vue、HmFooter.vue三个局部组件自己的样式与内容</p>
<p>3.在App.vue中，引入局部组件，创建局部对象，插入局部组件到app.vue中</p>
<p>头部局部组件HmMain.vue：</p>
<pre><code>&lt;template&gt;
  &lt;div class=&quot;hmmain&quot;&gt;
    我是hm-main
  &lt;/div&gt;
&lt;/template&gt;

&lt;script&gt;
export default &#123;

&#125;
&lt;/script&gt;

&lt;style&gt;
.hmmain&#123;
  width: 1000px;
  height: 500px;
  background-color: #f79646;
  color: white;
&#125;
&lt;/style&gt;
</code></pre>
<p>根组件App.vue:</p>
<pre><code>&lt;template&gt;
  &lt;div class=&quot;App&quot;&gt;
    &lt;!-- 4.插入组件 --&gt;
    &lt;!-- 头部组件 --&gt;
    &lt;HmHeader&gt;&lt;/HmHeader&gt;
    &lt;!-- 中间组件 --&gt;
    &lt;HmMain&gt;&lt;/HmMain&gt;
    &lt;!-- 尾部组件 --&gt;
    &lt;HmFooter&gt;&lt;/HmFooter&gt;
  &lt;/div&gt;
&lt;/template&gt;

&lt;script&gt;
// 2.引入局部组件
import HmMain from &#39;./components/HmMain.vue&#39;;
import HmFooter from &#39;./components/HmFooter.vue&#39;;
import HmHeader from &#39;./components/HmHeader.vue&#39;;
export default &#123;
// 3.运用到components中
  components:&#123;
    // 组件名：组件对象,同名时可省略
    HmFooter:HmFooter,
    HmHeader,
    HmMain
  &#125;
&#125;
&lt;/script&gt;

&lt;style&gt;
.App&#123;
  width: 500px;
  height: 700px;
  background-color: #87ceeb;
&#125;
&lt;/style&gt;
</code></pre>
<p>普通组件的注册使用-全局注册</p>
<p>1.特点</p>
<p>全局注册的组件，在项目的任何组件中都能使用</p>
<p>2.步骤</p>
<ol>
<li>创建.vue组件（三个组成部分）</li>
<li>main.js中进行全局注册</li>
</ol>
<p>3.使用方式</p>
<p>当成HTML标签直接使用</p>
<p>&lt;组件名&gt;&lt;&#x2F;组件名&gt;</p>
<p>4.注意</p>
<p>组件名规范 —&gt; 大驼峰命名法， 如 HmHeader</p>
<p>5.语法</p>
<p>Vue.component(‘组件名’, 组件对象)</p>
<p>案例：全局组件</p>
<p>先在components文件夹下创建全局组件的页面HmButton.vue，设置好页面</p>
<p>再到main.js中引入全局组件，并且创建全局组件的对象</p>
<p>在需要的组件页面中插入即可</p>
<p>HmButton.vue：</p>
<pre><code>&lt;template&gt;
  &lt;button class=&quot;hmbutton&quot;&gt;通用按钮&lt;/button&gt;
&lt;/template&gt;

&lt;script&gt;
export default &#123;

&#125;
&lt;/script&gt;

&lt;style&gt;
.hmbutton&#123;
  width: 100px;
  height: 50px;
  background-color: greenyellow;
  line-height: 10px;
  color: black;
&#125;
&lt;/style&gt;
</code></pre>
<p>main.js：</p>
<pre><code>import Vue from &#39;vue&#39;
import App from &#39;./App.vue&#39;
// 2.引入全局组件到main.js中，引用一定要在顶部
import HmButton from &#39;./components/HmButton&#39;

Vue.config.productionTip = false
// 3.全局注册
Vue.component(&#39;HmButton&#39;, HmButton)
new Vue(&#123;
  render: h =&gt; h(App),
&#125;).$mount(&#39;#app&#39;)
</code></pre>
<p>在需要插入的组件页面中插入即可</p>
<pre><code>&lt;template&gt;
  &lt;div class=&quot;hmfooter&quot;&gt;
    我是hm-footer
    &lt;!-- 插入需要渲染全局组件的位置 --&gt;
    &lt;HmButton&gt;&lt;/HmButton&gt;
  &lt;/div&gt;
&lt;/template&gt;
</code></pre>
<p>第四天</p>
<p>scoped解决样式冲突</p>
<p>写在组件中的样式会 全局生效 →  因此很容易造成多个组件之间的样式冲突问题。</p>
<ol>
<li><p>全局样式: 默认组件中的样式会作用到全局，任何一个组件中都会受到此样式的影响</p>
</li>
<li><p>局部样式: 可以给组件加上scoped 属性,可以让样式只作用于当前组件</p>
</li>
</ol>
<p>data必须是一个函数</p>
<p>一个组件的 data 选项必须是一个函数。目的是为了：保证每个组件实例，维护独立的一份数据对象。</p>
<p>每次创建新的组件实例，都会新执行一次data 函数，得到一个新对象</p>
<p>格式如下：</p>
<pre><code>export default &#123;
  data: function () &#123;
    return &#123;
     数据
    &#125;
  &#125;,
&#125;
</code></pre>
<p>组件通信</p>
<p>1.什么是组件通信？</p>
<p>组件通信，就是指组件与组件之间的数据传递</p>
<ul>
<li>组件的数据是独立的，无法直接访问其他组件的数据。</li>
<li>想使用其他组件的数据，就需要组件通信</li>
</ul>
<p>3.组件关系分类</p>
<ol>
<li>父子关系</li>
<li>非父子关系</li>
</ol>
<p>4.通信解决方案</p>
<p>5.父子通信流程</p>
<ol>
<li>父组件通过 props 将数据传递给子组件</li>
<li>子组件利用 $emit 通知父组件修改更新</li>
</ol>
<p>父向子通信</p>
<p>1.先在父组件中提供，子组件需要使用父组件的数据</p>
<p>   data(){return{数据名：更改的数据}}</p>
<p>2.在父组件页面中的子组件的标签中添加属性,给子组件页面传递数据</p>
<p>   :子组件需要渲染的名称&#x3D;”父组件设置的数据名”</p>
<p>3.在子组件页面中，通过props获取父组件传入过来的值</p>
<pre><code>props:[&#39;子组件需要渲染的名称&#39;]  ==&gt;&#123;&#123;子组件需要渲染的名称&#125;&#125;
</code></pre>
<p>父组件页面App.vue</p>
<pre><code>&lt;template&gt;
  &lt;div class=&quot;App&quot;&gt;
    我是父组件
    &lt;!-- 2.在父组件页面中的子组件的标签中添加属性,给子组件页面传递数据
        :子组件需要渲染的名称=&quot;父组件设置的数据名&quot;
    --&gt;
    &lt;Son :Stitle=&quot;Ftitle&quot;&gt;&lt;/Son&gt;
  &lt;/div&gt;
&lt;/template&gt;

&lt;script&gt;
import Son from &#39;./components/Son.vue&#39;
export default &#123;
  // 1.先在父组件中提供，子组件需要使用父组件的数据
//    data()&#123;return&#123;数据名：更改的数据&#125;&#125;
  data()&#123;
    return&#123;
      Ftitle:&#39;我是父传子的数据&#39;
    &#125;
  &#125;,
  components:&#123;
    Son
  &#125;
&#125;
&lt;/script&gt;

&lt;style&gt;
.App&#123;
  border: 1px,black, solid;
  height: 500px;
  width: 500px;
  font-size: 100px;
  background-color: pink;
  color: aqua;
&#125;
&lt;/style&gt;
</code></pre>
<p>子组件页面Son.vue:</p>
<pre><code>&lt;template&gt;
  &lt;div class=&quot;Son&quot;&gt;
    我是子组件
    &lt;!--&#123;&#123;子组件需要渲染的名称&#125;&#125; --&gt;
    &#123;&#123; Stitle &#125;&#125;
  &lt;/div&gt;
&lt;/template&gt;

&lt;script&gt;
export default &#123;
// 3.在子组件页面中，通过props获取父组件传入过来的值
// props:[&#39;子组件需要渲染的名称&#39;] 
props:[&#39;Stitle&#39;]
&#125;
&lt;/script&gt;

&lt;style&gt;
.Son&#123;
  margin: 20px 0;
  height: 500px;
  width: 500px;
  font-size: 100px;
  background-color: rgb(63, 181, 165);
  color: rgb(33, 34, 34);
&#125;
&lt;/style&gt;
</code></pre>
<p>子向父通信</p>
<p>子传父通信（通过子页面的逻辑代码，对父页面中的数据进行更改）</p>
<p>如，在子页面中通过点击按钮，即可修改父页面的数据</p>
<p>1.给子页面中的按钮添加点击事件，@click&#x3D;”Sclick”</p>
<p>2.在子页面的mothods方法中设置一个Sclick函数，通过this.$emit给父组件发生消息</p>
<p>this.$emit(‘子页面对该事件起的名称’,’需要传递的值’)</p>
<p>3.在父页面中，给子组件添加事件，@子页面对该事件起的名称&#x3D;”父页面中接收的函数名”</p>
<p>4.在父页面中的methods中，设置相应的函数</p>
<p>  父页面中接收的函数名（子传父数据的形参）{对相应的数据进行赋值}</p>
<p>父组件页面App.vue</p>
<pre><code>&lt;template&gt;
  &lt;div class=&quot;App&quot;&gt;
    我是父组件
&lt;!--  3.在父页面中，给子组件添加事件，@子页面对该事件起的名称=&quot;父页面中接收的函数名&quot; --&gt;
    &lt;Son :Stitle=&quot;Ftitle&quot; @ChangeTilte=&quot;Fchange&quot;&gt;&lt;/Son&gt;
  &lt;/div&gt;
&lt;/template&gt;

&lt;script&gt;
import Son from &#39;./components/Son.vue&#39;
export default &#123;
  data()&#123;
    return&#123;
      Ftitle:&#39;我是父传子的数据&#39;
    &#125;
  &#125;,
  methods:&#123;
    // 4.在父页面中的methods中，设置相应的函数
    //父页面中接收的函数名（子传父数据的形参）&#123;对相应的数据进行赋值&#125;
    Fchange(newChange)&#123;
      this.Ftitle=newChange
      console.log(111);
    &#125;
  &#125;,
  components:&#123;
    Son
  &#125;
&#125;
&lt;/script&gt;
</code></pre>
<p>子组件页面Son.vue:</p>
<pre><code>&lt;template&gt;
  &lt;div class=&quot;Son&quot;&gt;
    我是子组件
    &#123;&#123; Stitle &#125;&#125;
    &lt;!--  1.给子页面中的按钮添加点击事件，@click=&quot;子组件对应点击事件的名称&quot; --&gt;
    &lt;button @click=&quot;Sclick&quot;&gt;修改父组件的值&lt;/button&gt;
  &lt;/div&gt;
&lt;/template&gt;

&lt;script&gt;
export default &#123;
props:[&#39;Stitle&#39;],
methods:&#123;
  // 2.在子页面的mothods方法中设置一个函数，通过this.$emit给父组件发生消息
  Sclick()&#123;
// this.$emit(&#39;子页面对该事件起的名称&#39;,&#39;需要传递的值&#39;)
    this.$emit(&quot;ChangeTilte&quot;,&#39;父组件信息已更改&#39;)
    console.log(111);
  &#125;
&#125;
&#125;
&lt;/script&gt;
</code></pre>
<p>什么是props</p>
<p>1.Props 定义</p>
<p>组件上 注册的一些  自定义属性</p>
<p>2.Props 作用</p>
<p>向子组件传递数据</p>
<ol>
<li>可以 传递 任意数量 的prop</li>
<li>可以 传递 任意类型 的prop</li>
</ol>
<p>props校验</p>
<p>1.思考</p>
<p>组件的props可以乱传吗</p>
<p>2.作用</p>
<p>为组件的 prop 指定验证要求，不符合要求，控制台就会有错误提示  → 帮助开发者，快速发现错误</p>
<p>3.语法</p>
<ul>
<li><p>类型校验</p>
</li>
<li><p>非空校验</p>
</li>
<li><p>默认值</p>
</li>
<li><p>自定义校验</p>
<p>  props: {<br>    校验的属性名: {<br>      type: 类型,  &#x2F;&#x2F; Number String Boolean …<br>      required: true, &#x2F;&#x2F; 是否必填<br>      default: 默认值, &#x2F;&#x2F; 默认值<br>      validator (value) {<br>        &#x2F;&#x2F; 自定义校验逻辑<br>        return 是否通过校验<br>      }<br>    }<br>  },</p>
</li>
</ul>
<p>props&amp;data、单向数据流</p>
<p>1.共同点</p>
<p>都可以给组件提供数据</p>
<p>2.区别</p>
<ul>
<li>data 的数据是自己的  →   随便改  </li>
<li>prop 的数据是外部的  →   不能直接改，要遵循 单向数据流</li>
</ul>
<p>3.单向数据流：</p>
<p>父级props 的数据更新，会向下流动，影响子组件。这个数据流动是单向的</p>
<p>综合案例：小黑记事本（父与子，组块化）</p>
<p>渲染功能：</p>
<p>1.提供数据： 提供在公共的父组件 App.vue</p>
<p>2.通过父传子，将数据传递给TodoMain</p>
<p>3.利用 v-for渲染</p>
<p>添加功能：</p>
<p>1.手机表单数据  v-model</p>
<p>2.监听事件（回车+点击都要添加）</p>
<p>3.子传父，讲任务名称传递给父组件 App.vue</p>
<p>4.进行添加 unshift（自己的数据自己负责）</p>
<p>5.清空文本框输入的内容</p>
<p>6.对输入的空数据 进行判断</p>
<p>删除功能</p>
<p>1.监听事件（监听删除的点击） 携带id</p>
<p>2.子传父，讲删除的id传递给父组件的App.vue</p>
<p>3.进行删除filter（自己的数据 自己负责）</p>
<p>底部合计：</p>
<p>父传子  传list 渲染</p>
<p>清空功能：</p>
<p>子传父  通知父组件 → 父组件进行更新</p>
<p>持久化存储：</p>
<p>watch深度监视list的变化 -&gt; 往本地存储 -&gt;进入页面优先读取本地数据</p>
<p>父页面App.vue</p>
<pre><code>&lt;template&gt;
  &lt;section id=&quot;app&quot;&gt;
    &lt;!-- 父拿到对子的监听添加数据事件 --&gt;
    &lt;TodoHeader @add=&quot;handleradd&quot;&gt;&lt;/TodoHeader&gt;
    &lt;!-- 父将数据传给子进行渲染 ,监听删除事件 --&gt;
    &lt;TodoMain :list=&quot;list&quot; @del=&quot;handlerdel&quot;&gt;&lt;/TodoMain&gt;
    &lt;!-- 父将数据传给子进行渲染，监听清空事件 --&gt;
    &lt;TodoFooter :list=&quot;list&quot; @clear=&quot;handlerclear&quot; v-show=&quot;list.length&gt;0&quot;&gt;&lt;/TodoFooter&gt;
  &lt;/section&gt;
&lt;/template&gt;

&lt;script&gt;
import TodoFooter from &#39;./components/TodoFooter.vue&#39;;
import TodoHeader from &#39;./components/TodoHeader.vue&#39;;
import TodoMain from &#39;./components/TodoMain.vue&#39;;
export default &#123;
  components:&#123;
    TodoFooter,
    TodoHeader,
    TodoMain
  &#125;,
  data()&#123;
    // 添加任务
    return&#123;
      // 一进页面优先访问本地存储的数据否则访问固定数据
      list:JSON.parse(localStorage.getItem(&#39;list&#39;))||[
        &#123;id:1,name:&#39;跑步&#39;&#125;,
        &#123;id:2,name:&#39;跳绳十分钟&#39;&#125;,
        &#123;id:3,name:&#39;游泳半小时&#39;&#125;,
        &#123;id:4,name:&#39;爬山一下午&#39;&#125;,
      ]
    &#125;
  &#125;,
  methods:&#123;
    // 将从子拿到的数据进行添加
    handleradd(value)&#123;
      this.list.unshift(&#123;
        id:+new Date(),
        name:value
      &#125;)
    &#125;,
    // 将子传入的数据，在数组中进行删除
    handlerdel(value)&#123;
      // console.log(111);
      this.list=this.list.filter(item=&gt;item.id!==value)
    &#125;,
    handlerclear()&#123;
      this.list=[]
      console.log(111);
    &#125;
  &#125;,
  // 监听本地存储
  watch:&#123;
    list:&#123;
      deep:true,
      handler(newValue)&#123;
        // 一旦监视到数组有新的变化，就存储到本地中
        localStorage.setItem(&#39;list&#39;,JSON.stringify(newValue))
      &#125;
    &#125;
  &#125;
&#125;
&lt;/script&gt;
</code></pre>
<p>头部组块TodoHeader.vue：</p>
<pre><code>&lt;template&gt;
   &lt;!-- 输入框 --&gt;
   &lt;header class=&quot;header&quot;&gt;
      &lt;h1&gt;小黑记事本&lt;/h1&gt;
      &lt;input placeholder=&quot;请输入任务&quot; class=&quot;new-todo&quot; v-model=&quot;aname&quot;  @keyup.enter=&quot;add&quot;/&gt;
      &lt;!-- 在子页面中，通过v-model拿到数据，通过点击事件，将数据传输给父 --&gt;
      &lt;button class=&quot;add&quot; @click=&quot;add&quot;&gt;添加任务&lt;/button&gt;
   &lt;/header&gt;
&lt;/template&gt;

&lt;script&gt;
export default &#123;
  data()&#123;
    return&#123;
      aname:&#39;&#39;
    &#125;
  &#125;,
methods:&#123;
  // 子将获取的数据通过this.$emit传输给父
  add()&#123;
    // 判断添加字符串的格式
    if(this.aname===&#39;&#39;)
    &#123;
      alert(&#39;请输入正确的字符&#39;)
      return
    &#125;
    this.$emit(&#39;add&#39;,this.aname)
    // 添加完成后，将输入框的数据情空
    this.aname=&#39;&#39;
  &#125;
&#125;
&#125;
&lt;/script&gt;
</code></pre>
<p>列表区域TodoMain.vue：</p>
<pre><code>&lt;template&gt;
    &lt;!-- 列表区域 --&gt;
    &lt;section class=&quot;main&quot;&gt;
      &lt;ul class=&quot;todo-list&quot;&gt;
        &lt;!-- 子将父传的数据利用v-for进行渲染 --&gt;
        &lt;li v-for=&quot;(item,index) in list&quot; :key=&quot;item.id&quot; class=&quot;todo&quot;&gt;
          &lt;div class=&quot;view&quot;&gt;
            &lt;span class=&quot;index&quot;&gt;&#123;&#123; index+1 &#125;&#125;.&lt;/span&gt; &lt;label&gt;&#123;&#123; item.name &#125;&#125;&lt;/label&gt;
            &lt;!-- 添加删除事件 --&gt;
            &lt;button class=&quot;destroy&quot; @click=&quot;del(item.id)&quot;&gt;&lt;/button&gt;
          &lt;/div&gt;
        &lt;/li&gt;
      &lt;/ul&gt;
    &lt;/section&gt;
&lt;/template&gt;

&lt;script&gt;
export default &#123;
  // 获得父传入的数据
  props:&#123;
    list:Array
  &#125;,
  methods:&#123;
    del(id)&#123;
    // 将需要删除的数据传递给父
    this.$emit(&#39;del&#39;,id)
    // console.log(111);
  &#125;
  &#125;
&#125;
&lt;/script&gt;
</code></pre>
<p>底部区域组块TodoFooter.vue：</p>
<pre><code>&lt;template&gt;
  &lt;!-- 统计和清空 --&gt;
  &lt;footer class=&quot;footer&quot;&gt;
      &lt;!-- 统计 --&gt;
      &lt;span class=&quot;todo-count&quot;&gt;合 计:&lt;strong&gt; &#123;&#123; list.length &#125;&#125; &lt;/strong&gt;&lt;/span&gt;
      &lt;!-- 清空 --&gt;
      &lt;button class=&quot;clear-completed&quot;  @click=&quot;clear&quot;&gt;
        清空任务
      &lt;/button&gt;
    &lt;/footer&gt;
&lt;/template&gt;

&lt;script&gt;
export default &#123;
props:&#123;
  list:Array
&#125;,
methods:&#123;
  clear()&#123;
  this.$emit(&#39;clear&#39;)
  console.log(111);
&#125;
&#125;
&#125;
&lt;/script&gt;
</code></pre>
<p>非父子通信-event bus 事件总线</p>
<p>1.作用</p>
<p>非父子组件之间，进行简易消息传递。(复杂场景→ Vuex)</p>
<p>2.步骤</p>
<ol>
<li>创建一个都能访问的事件总线 （空Vue实例）<br>import Vue from ‘vue’<br>const Bus &#x3D; new Vue()<br>export default Bus</li>
<li>A组件（接受方），监听Bus的 $on事件<br>created () {<br>  Bus.$on(‘sendMsg’, (msg) &#x3D;&gt; {<br>    this.msg &#x3D; msg<br>  })<br>}</li>
<li>B组件（发送方），触发Bus的$emit事件<br>Bus.$emit(‘sendMsg’, ‘这是一个消息’)</li>
</ol>
<p>3.代码示例</p>
<p>EventBus.js</p>
<pre><code>import Vue from &#39;vue&#39;
const Bus  =  new Vue()
export default Bus
</code></pre>
<p>BaseA.vue(接受方)</p>
<pre><code>&lt;template&gt;
  &lt;div class=&quot;base-a&quot;&gt;
   我是A组件（接受方）
   &lt;p&gt;&#123;&#123;msg&#125;&#125;&lt;/p&gt;   
  &lt;/div&gt;
&lt;/template&gt;

&lt;script&gt;
import Bus from &#39;../utils/EventBus&#39;
export default &#123;
  data() &#123;
    return &#123;
      msg: &#39;&#39;,
    &#125;
  &#125;,
  created()&#123;
    Bus.$on(&#39;Msg&#39;,(msg)=&gt;&#123;
      this.msg=msg
      console.log(111);
    &#125;)
&#125;
&lt;/script&gt;
</code></pre>
<p>BaseB.vue(发送方)</p>
<pre><code>&lt;template&gt;
  &lt;div class=&quot;base-b&quot;&gt;
    &lt;div&gt;我是B组件（发布方）&lt;/div&gt;
    &lt;button @click=&quot;sendMsgFn&quot;&gt;发送消息&lt;/button&gt;
  &lt;/div&gt;
&lt;/template&gt;

&lt;script&gt;
import Bus from &#39;../utils/EventBus&#39;
export default &#123;
  methods:&#123;
    sendMsgFn()&#123;
      Bus.$emit(&#39;Msg&#39;,&#39;今天天气不错&#39;)
    &#125;
  &#125;
&#125;
&lt;/script&gt;
</code></pre>
<p>App.vue</p>
<pre><code>&lt;template&gt;
  &lt;div class=&quot;app&quot;&gt;
    &lt;BaseA&gt;&lt;/BaseA&gt;
    &lt;BaseB&gt;&lt;/BaseB&gt; 
  &lt;/div&gt;
&lt;/template&gt;

&lt;script&gt;
import BaseA from &#39;./components/BaseA.vue&#39;
import BaseB from &#39;./components/BaseB.vue&#39; 
export default &#123;
  components:&#123;
    BaseA,
    BaseB
  &#125;
&#125;
&lt;/script&gt;
</code></pre>
<p>非父子通信-provide&amp;inject</p>
<p>1.作用</p>
<p>跨层级共享数据</p>
<p>2.场景</p>
<p>3.语法</p>
<ol>
<li><p>父组件 provide提供数据</p>
<p> export default {<br>   provide () {<br>     return {<br>    &#x2F;&#x2F; 普通类型【非响应式】<br>    color: this.color,<br>    &#x2F;&#x2F; 复杂类型【响应式】<br>    userInfo: this.userInfo,<br>     }<br>   }<br> }</p>
</li>
</ol>
<p>2.子&#x2F;孙组件 inject获取数据</p>
<pre><code>export default &#123;
  inject: [&#39;color&#39;,&#39;userInfo&#39;],
  created () &#123;
    console.log(this.color, this.userInfo)
  &#125;
&#125;
</code></pre>
<p>v-model原理</p>
<p>1.原理：</p>
<p>v-model本质上是一个语法糖。例如应用在输入框上，就是value属性 和 input事件 的合写</p>
<pre><code>&lt;template&gt;
  &lt;div id=&quot;app&quot; &gt;
    &lt;input v-model=&quot;msg&quot; type=&quot;text&quot;&gt;

    &lt;input :value=&quot;msg&quot; @input=&quot;msg = $event.target.value&quot; type=&quot;text&quot;&gt;
  &lt;/div&gt;
&lt;/template&gt;
</code></pre>
<p>2.作用：</p>
<p>提供数据的双向绑定</p>
<ul>
<li>数据变，视图跟着变 :value</li>
<li>视图变，数据跟着变 @input</li>
</ul>
<p>在父页面中，将子组件与父页面的数据利用v-model中进行数据的双向绑定</p>
<p>在子组件中，用props来接收value,</p>
<p>.sync修饰符</p>
<p>1.作用</p>
<p>可以实现 子组件 与 父组件数据 的 双向绑定，简化代码</p>
<p>简单理解：子组件可以修改父组件传过来的props值</p>
<p>2.场景</p>
<p>封装弹框类的基础组件， visible属性 true显示 false隐藏</p>
<p>3.本质</p>
<p>.sync修饰符 就是 :属性名 和 @update:属性名 合写</p>
<p>4.语法</p>
<p>父组件</p>
<pre><code>//.sync写法
&lt;BaseDialog :visible.sync=&quot;isShow&quot; /&gt;
--------------------------------------
//完整写法
&lt;BaseDialog 
  :visible=&quot;isShow&quot; 
  @update:visible=&quot;isShow = $event&quot; 
/&gt;
</code></pre>
<p>子组件</p>
<pre><code>props: &#123;
  visible: Boolean
&#125;,

this.$emit(&#39;update:visible&#39;, false)
</code></pre>
<p>5.代码示例</p>
<p>App.vue</p>
<pre><code>&lt;template&gt;
  &lt;div class=&quot;app&quot;&gt;
    &lt;button @click=&quot;isShow=true&quot;&gt;退出按钮&lt;/button&gt;
    &lt;BaseDialog :visiable.sync=&quot;isShow&quot;&gt;&lt;/BaseDialog&gt;
  &lt;/div&gt;
&lt;/template&gt;

&lt;script&gt;
import BaseDialog from &#39;./components/BaseDialog.vue&#39;
export default &#123;
  data() &#123;
    return &#123;
      isShow: false,
    &#125;
  &#125;,
  components: &#123;
    BaseDialog,
  &#125;,
&#125;
&lt;/script&gt;

&lt;style&gt;
&lt;/style&gt;
</code></pre>
<p>BaseDialog.vue</p>
<pre><code>&lt;template&gt;
  &lt;div class=&quot;base-dialog-wrap&quot; v-show=&quot;visible&quot;&gt;
    &lt;div class=&quot;base-dialog&quot;&gt;
      &lt;div class=&quot;title&quot;&gt;
        &lt;h3&gt;温馨提示：&lt;/h3&gt;
        &lt;button class=&quot;close&quot; @click=&quot;close&quot;&gt;x&lt;/button&gt;
      &lt;/div&gt;
      &lt;div class=&quot;content&quot;&gt;
        &lt;p&gt;你确认要退出本系统么？&lt;/p&gt;
      &lt;/div&gt;
      &lt;div class=&quot;footer&quot;&gt;
        &lt;button&gt;确认&lt;/button&gt;
        &lt;button&gt;取消&lt;/button&gt;
      &lt;/div&gt;
    &lt;/div&gt;
  &lt;/div&gt;
&lt;/template&gt;

&lt;script&gt;
export default &#123;
  props: &#123;
    visible:Boolean
  &#125;,
  methods:&#123;
      close()&#123;
           this.$emit(&#39;update:visible&#39;,false)
      &#125;  
  &#125;
&#125;
&lt;/script&gt;
</code></pre>
<p>ref和$refs</p>
<p>1.作用</p>
<p>利用ref 和 $refs 可以用于 获取 dom 元素 或 组件实例</p>
<p>2.特点：</p>
<p>查找范围 →  当前组件内(更精确稳定)</p>
<p>3.语法</p>
<p>1.给要获取的盒子添加ref属性</p>
<pre><code>&lt;div ref=&quot;chartRef&quot;&gt;我是渲染图表的容器&lt;/div&gt;
</code></pre>
<p>2.获取时通过 $refs获取  this.$refs.chartRef 获取</p>
<pre><code>mounted () &#123;
  console.log(this.$refs.chartRef)
&#125;
</code></pre>
<p>4.注意</p>
<p>之前只用document.querySelect(‘.box’) 获取的是整个页面中的盒子</p>
<p>异步更新 &amp; $nextTick</p>
<p>$nextTick：等 DOM更新后,才会触发执行此方法里的函数体</p>
<p>语法: this.$nextTick(函数体)</p>
<pre><code>this.$nextTick(() =&gt; &#123;
  this.$refs.inp.focus()
&#125;)
</code></pre>
<p>注意：$nextTick 内的函数体 一定是箭头函数，这样才能让函数内部的this指向Vue实例</p>
<p>第五天</p>
<p>自定义指令</p>
<p>自定义指令</p>
<p>概念：自己定义的指令，可以封装一些DOM操作，扩展额外的功能</p>
<p>自定义指令语法</p>
<ul>
<li>全局注册<br>&#x2F;&#x2F;在main.js中<br>Vue.directive(‘指令名’, {<br>  “inserted” (el) {<br>    &#x2F;&#x2F; 可以对 el 标签，扩展额外功能<br>    el.focus()<br>  }<br>})</li>
<li>局部注册<br>&#x2F;&#x2F;在Vue组件的配置项中<br>directives: {<br>  “指令名”: {<br>    inserted () {<br>      &#x2F;&#x2F; 可以对 el 标签，扩展额外功能<br>      el.focus()<br>    }<br>  }<br>}</li>
<li>使用指令<br>注意：在使用指令的时候，一定要先注册，再使用，否则会报错<br>使用指令语法： v-指令名。如：<input type="text"  v-focus/><br>注册指令时不用加v-前缀，但使用时一定要加v-前缀</li>
</ul>
<p>指令中的配置项介绍</p>
<p>inserted:被绑定元素插入父节点时调用的钩子函数</p>
<p>el：使用指令的那个DOM元素</p>
<p>案例–v-color（自定义文字的颜色）</p>
<pre><code>&lt;template&gt;
  &lt;div&gt;
    &lt;p v-color=&quot;color1&quot;&gt;指令的颜色1&lt;/p&gt;
    &lt;p&gt;指令的颜色2&lt;/p&gt;
  &lt;/div&gt;
  
&lt;/template&gt;

&lt;script&gt;
export default &#123;
  data()&#123;
    return&#123;
      color1:&#39;red&#39;
    &#125;
  &#125;,
  // 定义局部自定义指令
  directives:&#123;
    // 自定义指令名称
    color:&#123;
      // 执行指令显示到页面的过程，el是触发的事件，binding.value是指令获取的值
      inserted(el,binding)&#123;
        // 将指令的内容文字颜色进行修改
        el.style.color=binding.value
        console.log(el,binding.value);
      &#125;,
      update(el,binding)&#123;
        // 相当于，指令中的值发生更改时，会重新赋值一遍并渲染
        el.style.color=binding.value
      &#125;
    &#125;
  &#125;
&#125;
&lt;/script&gt;
</code></pre>
<p>案例：v-loading（页面缓存效果）</p>
<pre><code>&lt;template&gt;
  &lt;div class=&quot;main&quot;&gt;
    &lt;!-- 给盒子添加v-loading自定义的指令，默认为true显示 --&gt;
    &lt;div class=&quot;box&quot;  v-loading=&quot;loading&quot;&gt;
      &lt;ul&gt;
        &lt;li v-for=&quot;item in list&quot; :key=&quot;item.id&quot; class=&quot;news&quot;&gt;
          &lt;div class=&quot;left&quot;&gt;
            &lt;div class=&quot;title&quot;&gt;&#123;&#123; item.title &#125;&#125;&lt;/div&gt;
            &lt;div class=&quot;info&quot;&gt;
              &lt;span&gt;&#123;&#123; item.source &#125;&#125;&lt;/span&gt;
              &lt;span&gt;&#123;&#123; item.time &#125;&#125;&lt;/span&gt;
            &lt;/div&gt;
          &lt;/div&gt;

          &lt;div class=&quot;right&quot;&gt;
            &lt;img :src=&quot;item.img&quot; alt=&quot;&quot;&gt;
          &lt;/div&gt;
        &lt;/li&gt;
      &lt;/ul&gt;
    &lt;/div&gt;
  &lt;/div&gt;
&lt;/template&gt;

&lt;script&gt;

// 安装axios =&gt;  yarn add axios
import axios from &#39;../axios&#39;

// 接口地址：http://hmajax.itheima.net/api/news
// 请求方式：get
export default &#123;
  data() &#123;
    return &#123;
      list: [],
      loading:true
    &#125;
  &#125;,
  async created() &#123;
    // 1. 发送请求获取数据
    const res = await axios.get(&#39;http://hmajax.itheima.net/api/news&#39;)
    setTimeout(() =&gt; &#123;
      // 2. 更新到 list 中
      this.list = res.data.data
      // 当监测到数据变化后，就立刻将loading的值转变为false
      this.loading=false
    &#125;, 2000)
  &#125;,
  directives:&#123;
  loading:&#123;
    // 只能初步渲染
    inserted(el,binding)&#123;
      // 判断，如果指令的值为true时，给相应的盒子添加loading类
      binding.value?el.classList.add(&#39;loading&#39;):el.classList.remove(&#39;loading&#39;)
    &#125;,
    // 数据有变化时，重新渲染
    update(el,binding)&#123;
      // 判断，指令内容为false时，给相应的盒子删除loading类
      binding.value?el.classList.add(&#39;loading&#39;):el.classList.remove(&#39;loading&#39;)
    &#125;,
  &#125;
  &#125;
&#125;
&lt;/script&gt;

&lt;style&gt;
/* 伪类 - 蒙层效果 */
.loading:before &#123;
  content: &#39;&#39;;
  position: absolute;
  left: 0;
  top: 0;
  width: 100%;
  height: 100%;
  background: #fff url(&#39;./assets/loading.gif&#39;) no-repeat center;
&#125;

.box &#123;
  width: 800px;
  min-height: 500px;
  border: 3px solid orange;
  border-radius: 5px;
  position: relative;
&#125;

.news &#123;
  display: flex;
  height: 120px;
  width: 600px;
  margin: 0 auto;
  padding: 20px 0;
  cursor: pointer;
&#125;

.news .left &#123;
  flex: 1;
  display: flex;
  flex-direction: column;
  justify-content: space-between;
  padding-right: 10px;
&#125;

.news .left .title &#123;
  font-size: 20px;
&#125;

.news .left .info &#123;
  color: #999999;
&#125;

.news .left .info span &#123;
  margin-right: 20px;
&#125;

.news .right &#123;
  width: 160px;
  height: 120px;
&#125;

.news .right img &#123;
  width: 100%;
  height: 100%;
  object-fit: cover;
&#125;&lt;/style&gt;
</code></pre>
<p>插槽-默认插槽（一个定制位置）</p>
<p>1.作用</p>
<p>让组件内部的一些 结构 支持 自定义</p>
<p>2.需求</p>
<p>将需要多次显示的对话框,封装成一个组件</p>
<p>3.插槽的基本语法</p>
<ol>
<li>组件内需要定制的结构部分，改用<slot></slot>占位</li>
<li>使用组件时, <MyDialog></MyDialog>标签内部, 传入结构替换slot</li>
<li>给插槽传入内容时，可以传入纯文本、html标签、组件</li>
</ol>
<p>插槽-后备内容（默认值）</p>
<p>通过插槽完成了内容的定制，传什么显示什么, 但是如果不传，则是空白</p>
<p>能否给插槽设置 默认显示内容 呢？</p>
<p>2.插槽的后备内容</p>
<p>封装组件时，可以为预留的 <slot> 插槽提供后备内容（默认内容）。</p>
<p>3.语法</p>
<p>在 <slot> 标签内，放置内容, 作为默认显示内容</p>
<p>4.效果</p>
<p>如果，在组件内容中输入文字，则会替代掉<slot></slot>里面的内容</p>
<p>如果，在组件内容中没有文字，则默认显示<slot></slot>里面的文字</p>
<p>插槽-具名插槽（多个定制位置）</p>
<p>1.需求</p>
<p>一个组件内有多处结构，需要外部传入标签，进行定制 </p>
<p>上面的弹框中有三处不同，但是默认插槽只能定制一个位置，这时候怎么办呢?</p>
<p>2.具名插槽语法</p>
<ul>
<li><p>多个slot使用name属性区分名字 </p>
</li>
<li><p>template配合v-slot:名字来分发对应标签</p>
</li>
</ul>
<p>3.v-slot的简写</p>
<p>v-slot写起来太长，vue给我们提供一个简单写法 v-slot： —&gt; #</p>
<p>作用域插槽</p>
<p>1.插槽分类</p>
<ul>
<li>默认插槽</li>
<li>具名插槽<br>插槽只有两种，作用域插槽不属于插槽的一种分类</li>
</ul>
<p>2.作用</p>
<p>定义slot 插槽的同时, 是可以传值的。给 插槽 上可以 绑定数据，将来 使用组件时可以用</p>
<p>3.场景</p>
<p>封装表格组件</p>
<p>4.使用步骤</p>
<ol>
<li>给 slot 标签, 以 添加属性的方式传值<br><slot :id="item.id" msg="测试文本"></slot></li>
<li>所有添加的属性, 都会被收集到一个对象中<br>{ id: 3, msg: ‘测试文本’ }</li>
<li>在template中, 通过  #插槽名&#x3D; “obj” 接收，默认插槽名为 default<br><MyTable :list="list"><br>  &lt;template #default&#x3D;”obj”&gt;<br>    &lt;button @click&#x3D;”del(obj.id)”&gt;删除</button><br>  </template><br></MyTable></li>
</ol>
<p>5.代码示例</p>
<p>App.vue</p>
<pre><code>&lt;template&gt;
  &lt;div&gt;
    &lt;MyTable :list=&quot;list&quot;&gt;
      &lt;!-- 删除 --&gt;
      &lt;!-- 父拿子插槽的数据 --&gt;
      &lt;!-- #default=&quot;obj&quot; --&gt;
      &lt;!-- #default是指默认插槽，obj里面则包含了插槽所携带的标签数据，obj是将插槽的数据封装成了一个对象 --&gt;
      &lt;!-- obj的内容为&#123;row:&#123; id: 1, name: &#39;张小花&#39;, age: 18 &#125;&#125; --&gt;
      &lt;template #default=&quot;obj&quot;&gt;
        &lt;button @click=&quot;del(obj.row.id)&quot;&gt;删除&lt;/button&gt;
      &lt;/template&gt;
    &lt;/MyTable&gt;
    &lt;MyTable :list=&quot;list2&quot;&gt;
      &lt;!-- 查看 --&gt;
      &lt;template #default=&quot;obj&quot;&gt;
        &lt;!-- obj携带的是对象的格式 --&gt;
        &lt;button @click=&quot;look(obj.row)&quot;&gt;查看&lt;/button&gt;
      &lt;/template&gt;
    &lt;/MyTable&gt;
  &lt;/div&gt;
&lt;/template&gt;

&lt;script&gt;
import MyTable from &#39;./components/MyTable.vue&#39;
export default &#123;
  data () &#123;
    return &#123;
      list: [
        &#123; id: 1, name: &#39;张小花&#39;, age: 18 &#125;,
        &#123; id: 2, name: &#39;孙大明&#39;, age: 19 &#125;,
        &#123; id: 3, name: &#39;刘德忠&#39;, age: 17 &#125;,
      ],
      list2: [
        &#123; id: 1, name: &#39;赵小云&#39;, age: 18 &#125;,
        &#123; id: 2, name: &#39;刘蓓蓓&#39;, age: 19 &#125;,
        &#123; id: 3, name: &#39;姜肖泰&#39;, age: 17 &#125;,
      ]
    &#125;
  &#125;,
  methods:&#123;
    del(id)&#123;
      this.list=this.list.filter(item=&gt;item.id!=id)
    &#125;,
    look(row)&#123;
    //  console.log(row);
    alert(`该学生的序号为：$&#123;row.id&#125;,姓名为：$&#123;row.name&#125;,年纪为：$&#123;row.age&#125;岁`)
    &#125;
  &#125;,
  components: &#123;
    MyTable,
  &#125;
&#125;
&lt;/script&gt;
</code></pre>
<p>MyTable.vue</p>
<pre><code>&lt;template&gt;
  &lt;table class=&quot;my-table&quot;&gt;
    &lt;thead&gt;
      &lt;tr&gt;
        &lt;th&gt;序号&lt;/th&gt;
        &lt;th&gt;姓名&lt;/th&gt;
        &lt;th&gt;年纪&lt;/th&gt;
        &lt;th&gt;操作&lt;/th&gt;
      &lt;/tr&gt;
    &lt;/thead&gt;
    &lt;tbody&gt;
      &lt;!-- 将父传子的数据进行渲染 --&gt;
      &lt;tr v-for=&quot;(item,index) in list&quot; :key=&quot;item.id&quot;&gt;
        &lt;td&gt;&#123;&#123; index+1 &#125;&#125;&lt;/td&gt;
        &lt;td&gt;&#123;&#123; item.name &#125;&#125;&lt;/td&gt;
        &lt;td&gt;&#123;&#123; item.age &#125;&#125;&lt;/td&gt;
        &lt;td&gt;
          &lt;!-- 插入插槽 ，对应的是父页面按钮的位置和数据--&gt;
          &lt;slot :row=&quot;item&quot;&gt;&lt;/slot&gt;
        &lt;/td&gt;
      &lt;/tr&gt;
    &lt;/tbody&gt;
  &lt;/table&gt;
&lt;/template&gt;

&lt;script&gt;
export default &#123;
  // 获得父传入的数据
  props:&#123;
    list:Array
  &#125;,
&#125;
&lt;/script&gt;

&lt;style scoped&gt;
.my-table &#123;
  width: 450px;
  text-align: center;
  border: 1px solid #ccc;
  font-size: 24px;
  margin: 30px auto;
&#125;
.my-table thead &#123;
  background-color: #1f74ff;
  color: #fff;
&#125;
.my-table thead th &#123;
  font-weight: normal;
&#125;
.my-table thead tr &#123;
  line-height: 40px;
&#125;
.my-table th,
.my-table td &#123;
  border-bottom: 1px solid #ccc;
  border-right: 1px solid #ccc;
&#125;
.my-table td:last-child &#123;
  border-right: none;
&#125;
.my-table tr:last-child td &#123;
  border-bottom: none;
&#125;
.my-table button &#123;
  width: 65px;
  height: 35px;
  font-size: 18px;
  border: 1px solid #ccc;
  outline: none;
  border-radius: 3px;
  cursor: pointer;
  background-color: #ffffff;
  margin-left: 5px;
&#125;
&lt;/style&gt;
</code></pre>
<p>综合案例 - 商品列表-MyTag组件抽离</p>
<p>需求说明</p>
<ol>
<li><p>my-tag 标签组件封装</p>
<p> (1) 双击显示输入框，输入框获取焦点</p>
<p> (2) 失去焦点，隐藏输入框</p>
<p> (3) 回显标签信息</p>
<p> (4) 内容修改，回车 → 修改标签信息</p>
</li>
<li><p>my-table 表格组件封装</p>
<p> (1) 动态传递表格数据渲染</p>
<p> (2) 表头支持用户自定义</p>
<p> (3) 主体支持用户自定义</p>
</li>
</ol>
<p>App.vue</p>
<pre><code>&lt;template&gt;
  &lt;div class=&quot;table-case&quot;&gt;
    &lt;MyTable :data=&quot;goods&quot;&gt;
      &lt;template #name&gt;
        &lt;th&gt;编号&lt;/th&gt;
        &lt;th&gt;名称&lt;/th&gt;
        &lt;th&gt;图片&lt;/th&gt;
        &lt;th width=&quot;100px&quot;&gt;标签&lt;/th&gt;
      &lt;/template&gt;
      &lt;!-- 接收组件&lt;slot&gt;传来的参数，是个对象obj，直接重构&#123;item,index&#125; --&gt;
      &lt;template #body=&quot;&#123;item,index&#125;&quot;&gt;
        &lt;td&gt;&#123;&#123;index+1&#125;&#125;&lt;/td&gt;
          &lt;td&gt;&#123;&#123; item.name &#125;&#125;&lt;/td&gt;
          &lt;td&gt;
            &lt;img :src=&quot;item.picture&quot; /&gt;
          &lt;/td&gt;
          &lt;td&gt;
            &lt;!-- 因为标签的位置需要更改，并且数据会实时更换，将标签处单独变成组件 --&gt;
            &lt;MyTab v-model=&quot;item.tag&quot;&gt;&lt;/MyTab&gt;
          &lt;/td&gt;

      &lt;/template&gt;
    &lt;/MyTable&gt;
  &lt;/div&gt;
&lt;/template&gt;

&lt;script&gt;
import MyTable from &quot;./components/MyTable.vue&quot;
import MyTab from &quot;./components/MyTab.vue&quot;
export default &#123;
  name: &#39;TableCase&#39;,
  components: &#123;
    MyTab,
    MyTable
  &#125;,
  data() &#123;
    return &#123;
      text:&#39;仙女裙&#39;,
      goods: [
        &#123;
          id: 101,
          picture:
            &#39;https://yanxuan-item.nosdn.127.net/f8c37ffa41ab1eb84bff499e1f6acfc7.jpg&#39;,
          name: &#39;梨皮朱泥三绝清代小品壶经典款紫砂壶&#39;,
          tag: &#39;茶具&#39;,
        &#125;,
        &#123;
          id: 102,
          picture:
            &#39;https://yanxuan-item.nosdn.127.net/221317c85274a188174352474b859d7b.jpg&#39;,
          name: &#39;全防水HABU旋钮牛皮户外徒步鞋山宁泰抗菌&#39;,
          tag: &#39;男鞋&#39;,
        &#125;,
        &#123;
          id: 103,
          picture:
            &#39;https://yanxuan-item.nosdn.127.net/cd4b840751ef4f7505c85004f0bebcb5.png&#39;,
          name: &#39;毛茸茸小熊出没，儿童羊羔绒背心73-90cm&#39;,
          tag: &#39;儿童服饰&#39;,
        &#125;,
        &#123;
          id: 104,
          picture:
            &#39;https://yanxuan-item.nosdn.127.net/56eb25a38d7a630e76a608a9360eec6b.jpg&#39;,
          name: &#39;基础百搭，儿童套头针织毛衣1-9岁&#39;,
          tag: &#39;儿童服饰&#39;,
        &#125;,
      ],
    &#125;
  &#125;,
&#125;
&lt;/script&gt;

&lt;style lang=&quot;less&quot; scoped&gt;
.table-case &#123;
  width: 1000px;
  margin: 50px auto;
  img &#123;
    width: 100px;
    height: 100px;
    object-fit: contain;
    vertical-align: middle;
  &#125;
&#125;
&lt;/style&gt;
</code></pre>
<p>MyTab.vue</p>
<pre><code>&lt;template&gt;
  &lt;div class=&quot;my-tag&quot;&gt;
      &lt;input
        @keyup.enter=&quot;Enter&quot;
        v-focus
        ref=&quot;inp&quot;
        v-if=&quot;inp&quot;
        class=&quot;input&quot;
        type=&quot;text&quot;
        @blur=&quot;inp=false&quot;
        :value=&quot;value&quot;
        placeholder=&quot;输入标签&quot;
      /&gt;
      &lt;div class=&quot;text&quot;
      v-else
      @click=&quot;hit&quot;&gt;
        &#123;&#123; value &#125;&#125;
      &lt;/div&gt;
    &lt;/div&gt;
&lt;/template&gt;

&lt;script&gt;
// 1.点击文字的时候，显示input,点击其他处的时候，再将其切换为文本格式，隐藏对话框
//   input和div切换   v-if,v-else控制显示
//   点击文本切换到对话框的形式   @click=&quot;hit&quot;
//   切换为对话框时，要立刻自动获取光标
//      1.利用ref和，this.$nextTick()自动获取光标
//      2.将获取光标封装为一个指令，全局自定义指令  v-focus
//   点击其他处的时候，失去焦点，返回为文本  @blur=&quot;将其赋值为false&quot;
// 2.对话框中要自动回显内容(当切换到对话框的时候，里面的内容能显示出原本的数据),并且修改数据
//    回显的数据是在父组件中，就需要父与子的通信
//    利用v-model进行数据的双向绑定就更加方便
//    v-model=:value+@input （:value是指父页面的数据，@input将子的数据更改传回给父）
//    在input中输入内容时，点击回车，将数据传递给父组件  @keyup.enter=&quot;Enter&quot;,  this.$emit(&#39;input&#39;,e.target.value)
export default &#123;
  // 接收v-model传来的数据
  props:&#123;
    value:String
  &#125;,
  data()&#123;
    return&#123;
      inp:false
    &#125;
  &#125;,
  methods:&#123;
    hit()&#123;
      this.inp=true
      // 1.切换为input时，要立刻自动获取光标
      // this.$nextTick(()=&gt;&#123;
      //   this.$refs.inp.focus()
      // &#125;)
    &#125;,
    // 监视回车，就将数据传递给父组件
    Enter(e)&#123;
      // 判断
      if(e.target.value===&#39;&#39;)
      return alert(&#39;请出入正确的文字&#39;)
      // 将输入框的内容传递给父组件
      this.$emit(&#39;input&#39;,e.target.value)
      // console.log(11);
    &#125;
  &#125;
&#125;
&lt;/script&gt;

&lt;style lang=&quot;less&quot; scoped&gt;
.my-tag &#123;
    cursor: pointer;
    .input &#123;
      appearance: none;
      outline: none;
      border: 1px solid #ccc;
      width: 100px;
      height: 40px;
      box-sizing: border-box;
      padding: 10px;
      color: #666;
      &amp;::placeholder &#123;
        color: #666;
      &#125;
    &#125;
  &#125;
&lt;/style&gt;
</code></pre>
<p>MyTable.vue</p>
<pre><code>&lt;template&gt;
  &lt;!-- 将表格也变成动态的数据，就需要将其封装为组件 --&gt;
  &lt;table class=&quot;my-table&quot;&gt;
    &lt;!-- 让表单的结构不能写死，动态的变化 --&gt;
      &lt;thead&gt;
        &lt;tr&gt;
          &lt;slot name=&quot;head&quot;&gt;&lt;/slot&gt;
        &lt;/tr&gt;
      &lt;/thead&gt;
      &lt;tbody&gt;
        &lt;tr v-for=&quot;(item,index) in data&quot; :key=&quot;item.id&quot;&gt;
          &lt;!-- 将数组对应的item和index传给插槽 --&gt;
          &lt;slot name=&quot;body&quot; :item=&quot;item&quot; :index=&quot;index&quot;&gt;&lt;/slot&gt;
        &lt;/tr&gt;
      &lt;/tbody&gt;
    &lt;/table&gt;
&lt;/template&gt;

&lt;script&gt;
export default &#123;
  props:&#123;
    data:Array
  &#125;
&#125;
&lt;/script&gt;

&lt;style lang=&quot;less&quot; scoped&gt;
.my-table &#123;
    width: 100%;
    border-spacing: 0;
    img &#123;
      width: 100px;
      height: 100px;
      object-fit: contain;
      vertical-align: middle;
    &#125;
    th &#123;
      background: #f5f5f5;
      border-bottom: 2px solid #069;
    &#125;
    td &#123;
      border-bottom: 1px dashed #ccc;
    &#125;
    td,
    th &#123;
      text-align: center;
      padding: 10px;
      transition: all 0.5s;
      &amp;.red &#123;
        color: red;
      &#125;
    &#125;
    .none &#123;
      height: 100px;
      line-height: 100px;
      color: #999;
    &#125;
  &#125;
&lt;/style&gt;
</code></pre>
<p>路由的基本使用</p>
<p>1.目标</p>
<p>认识插件 VueRouter，掌握 VueRouter 的基本使用步骤</p>
<p>2.作用</p>
<p>修改地址栏路径时，切换显示匹配的组件</p>
<p>3.说明</p>
<p>Vue 官方的一个路由插件，是一个第三方包</p>
<p>4.官网</p>
<p><a target="_blank" rel="noopener" href="https://v3.router.vuejs.org/zh/">https://v3.router.vuejs.org/zh/</a></p>
<p>5.VueRouter的使用（5+2）</p>
<p>固定5个固定的步骤（不用死背，熟能生巧）</p>
<ol>
<li>下载 VueRouter 模块到当前工程，版本3.6.5，只需一次即可<br>yarn add <a href="mailto:&#118;&#117;&#x65;&#x2d;&#114;&#111;&#x75;&#x74;&#101;&#114;&#64;&#51;&#x2e;&#54;&#x2e;&#53;">&#118;&#117;&#x65;&#x2d;&#114;&#111;&#x75;&#x74;&#101;&#114;&#64;&#51;&#x2e;&#54;&#x2e;&#53;</a></li>
<li>main.js中引入VueRouter<br>import VueRouter from ‘vue-router’</li>
<li>安装注册<br>Vue.use(VueRouter)</li>
<li>创建路由对象<br>const router &#x3D; new VueRouter()</li>
<li>注入，将路由对象注入到new Vue实例中，建立关联<br>new Vue({<br>  render: h &#x3D;&gt; h(App),<br>  router:router<br>}).$mount(‘#app’)</li>
</ol>
<p>当我们配置完以上5步之后 就可以看到浏览器地址栏中的路由 变成了 &#x2F;#&#x2F;的形式。表示项目的路由已经被Vue-Router管理了</p>
<p>6.代码示例</p>
<p>main.js</p>
<pre><code>// 路由的使用步骤 5  + 2
// 5个基础步骤
// 1. 下载 v3.6.5
// yarn add vue-router@3.6.5
//npm install vue-router@3.6.5
// 2. 引入
// 3. 安装注册 Vue.use(Vue插件)
// 4. 创建路由对象
// 5. 注入到new Vue中，建立关联


import VueRouter from &#39;vue-router&#39;
Vue.use(VueRouter) // VueRouter插件初始化

const router = new VueRouter()

new Vue(&#123;
  render: h =&gt; h(App),
  router
&#125;).$mount(&#39;#app&#39;)
</code></pre>
<p>7.两个核心步骤</p>
<ol>
<li><p>创建需要的组件 (views目录)，配置路由规则<br>main.js中配置</p>
</li>
<li><p>配置导航，配置路由出口(路径匹配的组件显示的位置)<br>App.vue<br><div class="footer_wrap"><br>  <a href="#/find">发现音乐</a><br>  <a href="#/my">我的音乐</a><br>  <a href="#/friend">朋友</a><br></div><br><div class="top"><br>&#x2F;&#x2F;页面需要显示的地方，路由的出口<br>  <router-view></router-view><br></div></p>
</li>
</ol>
<p>第七天</p>
<p>一、声明式导航-router-link导航链接</p>
<p>vue-router 提供了一个全局组件 router-link (取代 a 标签)</p>
<ul>
<li>能跳转，配置 to 属性指定路径(必须) 。本质还是 a 标签 ，to 无需 #</li>
<li>能高亮，默认就会提供高亮类名，可以直接设置高亮样式</li>
</ul>
<p>语法： <router-link to="path的值">发现音乐</router-link></p>
<pre><code>  &lt;div&gt;
    &lt;div class=&quot;footer_wrap&quot;&gt;
      &lt;router-link to=&quot;/find&quot;&gt;发现音乐&lt;/router-link&gt;
      &lt;router-link to=&quot;/my&quot;&gt;我的音乐&lt;/router-link&gt;
      &lt;router-link to=&quot;/friend&quot;&gt;朋友&lt;/router-link&gt;
    &lt;/div&gt;
    &lt;div class=&quot;top&quot;&gt;
      &lt;!-- 路由出口 → 匹配的组件所展示的位置 --&gt;
      &lt;router-view&gt;&lt;/router-view&gt;
    &lt;/div&gt;
  &lt;/div&gt;
</code></pre>
<p>3.通过router-link自带的两个样式进行高亮</p>
<p>使用router-link跳转后，我们发现。当前点击的链接默认加了两个class的值 router-link-exact-active和router-link-active</p>
<p>我们可以给任意一个class属性添加高亮样式即可实现功能</p>
<p>二、声明式导航-两个类名</p>
<p>当我们使用<router-link></router-link>跳转时，自动给当前导航加了两个类名</p>
<p>1.router-link-active</p>
<p>模糊匹配（用的多）</p>
<p>to&#x3D;”&#x2F;my”  可以匹配 &#x2F;my    &#x2F;my&#x2F;a    &#x2F;my&#x2F;b    ….  </p>
<p>只要是以&#x2F;my开头的路径 都可以和 to&#x3D;”&#x2F;my”匹配到</p>
<p>2.router-link-exact-active</p>
<p>精确匹配</p>
<p>to&#x3D;”&#x2F;my” 仅可以匹配  &#x2F;my</p>
<p>三、声明式导航-自定义类名（了解）</p>
<p>1.问题</p>
<p>router-link的两个高亮类名 太长了，我们希望能定制怎么办</p>
<p>2.解决方案</p>
<p>我们可以在创建路由对象时，额外配置两个配置项即可。 linkActiveClass和linkExactActiveClass</p>
<pre><code>const router = new VueRouter(&#123;
  routes: [...],
  linkActiveClass: &quot;类名1&quot;,
  linkExactActiveClass: &quot;类名2&quot;
&#125;)

// 创建了一个路由对象
const router = new VueRouter(&#123;
  routes: [
    ...
  ], 
  linkActiveClass: &#39;active&#39;, // 配置模糊匹配的类名
  linkExactActiveClass: &#39;exact-active&#39; // 配置精确匹配的类名
&#125;)
</code></pre>
<p>四、声明式导航-查询参数传参</p>
<p>1.目标</p>
<p>在跳转路由时，进行传参</p>
<p>比如：现在我们在搜索页点击了热门搜索链接，跳转到详情页，需要把点击的内容带到详情页，改怎么办呢？</p>
<p>2.跳转传参</p>
<p>我们可以通过两种方式，在跳转的时候把所需要的参数传到其他页面中</p>
<ul>
<li>查询参数传参</li>
<li>动态路由传参</li>
</ul>
<p>3.查询参数传参</p>
<ul>
<li>如何传参？<br><router-link to="/path?参数名=值"></router-link></li>
<li>如何接受参数<br>固定用法：$router.query.参数名</li>
</ul>
<p>例如：从首页home.vue携带参数跳转到search.vue，并在search.vue中显示携带的参数</p>
<p>home.vue</p>
<pre><code>&lt;router-link to=&quot;/search?name=黑马程序员&quot;&gt;黑马程序员&lt;/router-link&gt;
</code></pre>
<p>search.vue</p>
<pre><code>&lt;p&gt;搜索关键字:&#123;&#123; $route.query.name &#125;&#125; &lt;/p&gt;
</code></pre>
<p>五、声明式导航-动态路由传参</p>
<p>1.动态路由传参方式</p>
<ul>
<li>配置动态路由<br>动态路由后面的参数可以随便起名，但要有语义<br>const router &#x3D; new VueRouter({<br>  routes: [<br>    …,<br>    {<br>      path: ‘&#x2F;search&#x2F;:words’,<br>      component: Search<br>    }<br>  ]<br>})</li>
<li>配置导航链接<br>to&#x3D;”&#x2F;path&#x2F;参数值”</li>
<li>对应页面组件接受参数<br>$route.params.参数名<br>params后面的参数名要和动态路由配置的参数保持一致</li>
</ul>
<p>2.查询参数传参 VS 动态路由传参</p>
<ol>
<li>查询参数传参  (比较适合传多个参数) <ol>
<li>跳转：to&#x3D;”&#x2F;path?参数名&#x3D;值&amp;参数名2&#x3D;值”</li>
<li>获取：$route.query.参数名</li>
</ol>
</li>
<li>动态路由传参 (优雅简洁，传单个参数比较方便)<ol>
<li>配置动态路由：path: “&#x2F;path&#x2F;:参数名” </li>
<li>跳转：to&#x3D;”&#x2F;path&#x2F;参数值”</li>
<li>获取：$route.params.参数名<br>注意：动态路由也可以传多个参数，但一般只传一个</li>
</ol>
</li>
</ol>
<p>3.总结</p>
<p>声明式导航跳转时, 有几种方式传值给路由页面？</p>
<ul>
<li>查询参数传参（多个参数）</li>
<li>动态路由传参（一个参数，优雅简洁）</li>
</ul>
<p>八、Vue路由-404</p>
<p>1.作用</p>
<p>当路径找不到匹配时，给个提示页面</p>
<p>2.位置</p>
<p>404的路由，虽然配置在任何一个位置都可以，但一般都配置在其他路由规则的最后面</p>
<p>3.语法</p>
<p>path: “*”   (任意路径) – 前面不匹配就命中最后这个</p>
<pre><code>import NotFind from &#39;@/views/NotFind&#39;

const router = new VueRouter(&#123;
  routes: [
    ...
    &#123; path: &#39;*&#39;, component: NotFind &#125; //最后一个
  ]
&#125;)
</code></pre>
<p>十、编程式导航-两种路由跳转方式</p>
<p>1.问题</p>
<p>点击按钮跳转如何实现？</p>
<p>2.方案</p>
<p>编程式导航：用JS代码来进行跳转</p>
<p>3.语法</p>
<p>两种语法：</p>
<ul>
<li>path 路径跳转 （简易方便）</li>
<li>name 命名路由跳转 (适合 path 路径长的场景)</li>
</ul>
<p>4.path路径跳转语法</p>
<p>特点：简易方便</p>
<pre><code>//简单写法
this.$router.push(&#39;路由路径&#39;)

//完整写法
this.$router.push(&#123;
  path: &#39;路由路径&#39;
&#125;)
</code></pre>
<p>5.代码演示 path跳转方式</p>
<p>给按钮添加点击事件@click&#x3D;”search”</p>
<pre><code>  methods:&#123;
    search()&#123;
      this.$router.push(&#39;/search&#39;)
    &#125;
  &#125;
</code></pre>
<p>6.name命名路由跳转</p>
<p>特点：适合 path 路径长的场景</p>
<p>语法：</p>
<ul>
<li>路由规则，必须配置name配置项，在main.js<br>{ name: ‘路由名’, path: ‘&#x2F;path&#x2F;xxx’, component: XXX },</li>
<li>通过name来进行跳转<br>this.$router.push({<br>  name: ‘路由名’<br>})</li>
</ul>
<p>十一、编程式导航-path路径跳转传参</p>
<p>1.问题</p>
<p>点击搜索按钮，跳转需要把文本框中输入的内容传到下一个页面如何实现？</p>
<p>2.两种传参方式</p>
<p>1.查询参数 </p>
<p>2.动态路由传参</p>
<p>3.传参</p>
<p>两种跳转方式，对于两种传参方式都支持：</p>
<p>① path 路径跳转传参</p>
<p>② name 命名路由跳转传参</p>
<p>4.path路径跳转传参（query传参）</p>
<pre><code>//简单写法
this.$router.push(&#39;/路径?参数名1=参数值1&amp;参数2=参数值2&#39;)
//完整写法
this.$router.push(&#123;
  path: &#39;/路径&#39;,
  query: &#123;
    参数名1: &#39;参数值1&#39;,
    参数名2: &#39;参数值2&#39;
  &#125;
&#125;)
</code></pre>
<p>接受参数的方式依然是：$route.query.参数名</p>
<p>home.vue</p>
<pre><code>&lt;script&gt;
export default &#123;
  data()&#123;
    return&#123;
      // v-model绑定输入框的内容
      inp:&#39;&#39;
    &#125;
  &#125;,
  name: &#39;FindMusic&#39;,
  methods:&#123;
    search()&#123;
      console.log(this.inp);
      this.$router.push(`/search?name=$&#123;this.inp&#125;`)
    &#125;
  &#125;
&#125;
&lt;/script&gt;
</code></pre>
<p>search.vue</p>
<pre><code>&lt;p&gt;搜索关键字:&#123;&#123; $route.query.name &#125;&#125; &lt;/p&gt;
</code></pre>
<p>5.path路径跳转传参（动态路由传参）</p>
<pre><code>//简单写法
this.$router.push(&#39;/路径/参数值&#39;)
//完整写法
this.$router.push(&#123;
  path: &#39;/路径/参数值&#39;
&#125;)
</code></pre>
<p>接受参数的方式依然是：$route.params.参数值</p>
<p>案例：面板基础版</p>
<p>实现功能</p>
<ul>
<li>首页请求渲染</li>
<li>跳转传参 到 详情页，详情页动态渲染</li>
<li>组件缓存，性能优化</li>
</ul>
<p>1.路由配置</p>
<p>index.js(专门用来设置路由的js)</p>
<pre><code>import Vue from &#39;vue&#39;
import VueRouter from &quot;vue-router&quot;;
import Article from &#39;@/views/Article&#39;
import ArticleDetail from &#39;@/views/ArticleDetail&#39;
import Collect from &#39;@/views/Collect&#39;
import Layout from &#39;@/views/Layout&#39;
import Like from &#39;@/views/Like&#39;
import User from &#39;@/views/User&#39;
Vue.use(VueRouter)

// 一共6个页面，2个一级路由，4个二级页面
// Layout:带底部的导航条，和中间位置，一级路由，内有4个二级路由
//    Article=&gt;列表信息
//    Collect=&gt;收藏
//    Like=&gt;喜欢
//    User=&gt;用户
// ArticleDetail：列表的详细信息，属于一级路由

const router = new VueRouter(&#123;
  routes: [
    // 一级路由
    &#123;
      path: &#39;/&#39;,
      component: Layout,
      children: [
        // 二级路由
        &#123;
          path: &#39;/article&#39;,
          component: Article
        &#125;,
        &#123;
          path: &#39;/collect&#39;,
          component: Collect
        &#125;,
        &#123;
          path: &#39;/like&#39;,
          component: Like
        &#125;
        , &#123;
          path: &#39;/user&#39;,
          component: User
        &#125;
      ]
    &#125;,
    &#123;
        //动态传参
      path: &#39;/articleDetail/:id&#39;,
      component: ArticleDetail
    &#125;
  ]
&#125;)

export default router
</code></pre>
<p>2.首页请求渲染</p>
<p>1.安装axios </p>
<p>2.看接口文档，确认请求方式，请求地址，请求参数</p>
<p>3.created中发送请求，获取数据，存储到data中</p>
<p>4.页面动态渲染</p>
<pre><code>&lt;script&gt;
import axios from &#39;axios&#39;; 
// 请求地址: https://mock.boxuegu.com/mock/3083/articles
// 请求方式: get
// 安装axios
// 使其一进页面，就获取数据，created()中进行
// 根据数据对其相应部分进行渲染
export default &#123;
  name: &#39;ArticlePage&#39;,
  data () &#123;
    return &#123;
      list:[]
    &#125;
  &#125;,
  async created()&#123;
    const res=await axios.get(&#39;https://mock.boxuegu.com/mock/3083/articles&#39;)
    this.list=res.data.result.rows
    console.log(this.list);
  &#125;
&#125;
&lt;/script&gt;
</code></pre>
<p>3.动态路由传参</p>
<p>改造路由</p>
<p>router&#x2F;index.js</p>
<pre><code>...
  &#123;
      path: &#39;/detail/:id&#39;,
      component: ArticleDetail
  &#125;
</code></pre>
<p>Article.vue</p>
<pre><code>&lt;div class=&quot;article-item&quot; 
     v-for=&quot;item in articelList&quot; :key=&quot;item.id&quot; 
     @click=&quot;$router.push(`/detail/$&#123;item.id&#125;`)&quot;&gt;
       ....
 &lt;/div&gt;
</code></pre>
<p>ArticleDetail.vue</p>
<pre><code>  created()&#123;
    console.log(this.$route.params.id)
  &#125;
</code></pre>
<p>4.点击回退跳转到上一页</p>
<p>ArticleDetail.vue</p>
<pre><code>&lt;template&gt;
  &lt;div class=&quot;article-detail-page&quot;&gt;
    &lt;nav class=&quot;nav&quot;&gt;&lt;span class=&quot;back&quot; @click=&quot;$router.back()&quot;&gt;&amp;lt;&lt;/span&gt; 面经详情&lt;/nav&gt;
     ....
  &lt;/div&gt;
&lt;/template&gt;
</code></pre>
<p>5.详情页渲染</p>
<pre><code>&lt;template&gt;
  &lt;div class=&quot;article-detail-page&quot;&gt;
    &lt;nav class=&quot;nav&quot;&gt;&lt;span class=&quot;back&quot; @click=&quot;$router.back()&quot;&gt;&amp;lt;&lt;/span&gt; 面经详情&lt;/nav&gt;
    &lt;header class=&quot;header&quot;&gt;
      &lt;h1&gt;&#123;&#123; this.list. stem&#125;&#125;&lt;/h1&gt;
      &lt;p&gt;&#123;&#123; this.list.createAt&#125;&#125; | &#123;&#123; this.list.views&#125;&#125; 浏览量 | &#123;&#123; this.list.lickCount&#125;&#125; 点赞数&lt;/p&gt;
      &lt;p&gt;
        &lt;img
          :src=&quot;this.list.creatorAvatar&quot;
          alt=&quot;&quot;
        /&gt;
        &lt;span&gt;&#123;&#123; this.list.creatorName&#125;&#125;&lt;/span&gt;
      &lt;/p&gt;
    &lt;/header&gt;
    &lt;main class=&quot;body&quot;&gt;
      &#123;&#123; this.list.content&#125;&#125;
    &lt;/main&gt;
  &lt;/div&gt;
&lt;/template&gt;

&lt;script&gt;
import axios from &#39;axios&#39;
// 请求地址: https://mock.boxuegu.com/mock/3083/articles/:id
// 请求方式: get
export default &#123;
  name: &quot;ArticleDetailPage&quot;,
  data() &#123;
    return &#123;
      list:&#123;&#125;,
    &#125;
  &#125;,
  async created()&#123;
    const id=this.$route.params.id
    const res=await axios.get(`https://mock.boxuegu.com/mock/3083/articles/$&#123;id&#125;`)
    this.list=res.data.result
    console.log(res.data.result);
    // console.log(this.$route.params.id);
    // console.log(111);
  &#125;
&#125;
&lt;/script&gt;

&lt;style lang=&quot;less&quot; scoped&gt;
.article-detail-page &#123;
  .nav &#123;
    height: 44px;
    border-bottom: 1px solid #e4e4e4;
    line-height: 44px;
    text-align: center;
    .back &#123;
      font-size: 18px;
      color: #666;
      position: absolute;
      left: 10px;
      top: 0;
      transform: scale(1, 1.5);
    &#125;
  &#125;
  .header &#123;
    padding: 0 15px;
    p &#123;
      color: #999;
      font-size: 12px;
      display: flex;
      align-items: center;
    &#125;
    img &#123;
      width: 40px;
      height: 40px;
      border-radius: 50%;
      overflow: hidden;
    &#125;
  &#125;
  .body &#123;
    padding: 0 15px;
  &#125;
&#125;
&lt;/style&gt;
</code></pre>
<p>6.缓存组件</p>
<p>keep-alive 是 Vue 的内置组件，当它包裹动态组件时，会缓存不活动的组件实例，而不是销毁它们。</p>
<p>keep-alive 是一个抽象组件：它自身不会渲染成一个 DOM 元素，也不会出现在父组件中。</p>
<p>优点：</p>
<p>在组件切换过程中把切换出去的组件保留在内存中，防止重复渲染DOM，</p>
<p>减少加载时间及性能消耗，提高用户体验性。</p>
<p>keep-alive的三个属性</p>
<p>① include  ： 组件名数组，只有匹配的组件会被缓存</p>
<p>② exclude ： 组件名数组，任何匹配的组件都不会被缓存</p>
<p>③ max       ： 最多可以缓存多少组件实例</p>
<p>额外的两个生命周期钩子</p>
<p>keep-alive的使用会触发两个生命周期函数</p>
<p>activated 当组件被激活（使用）的时候触发 →  进入这个页面的时候触发</p>
<p>deactivated 当组件不被使用的时候触发      →  离开这个页面的时候触发</p>
<p>组件缓存后就不会执行组件的created, mounted, destroyed 等钩子了</p>
<p>所以其提供了actived 和deactived钩子，帮我们实现业务需求。</p>
<pre><code>&lt;template&gt;
  &lt;div class=&quot;h5-wrapper&quot; &gt;
    &lt;!-- 需求：用户回到layout时，能显示，跳转之前的页面 --&gt;
    &lt;!-- 使用keep-alive将layout跳转之前的内容进行一个缓存，但是不需要缓存detail中的内容，需要用得Include属性 --&gt;
    &lt;!-- include的内容优先使用，需要缓存页面中自定义的name,没有设置的话，就使用页面名 --&gt;
    &lt;keep-alive :include=&quot;[&#39;LayoutPage&#39;]&quot;&gt;
      &lt;router-view&gt;&lt;/router-view&gt;
    &lt;/keep-alive&gt;
    &lt;!-- 
         activated 当组件被激活（使用）的时候触发 →  进入这个页面的时候触发

         deactivated 当组件不被使用的时候触发  →  离开这个页面的时候触发
         
         组件缓存后就不会执行组件的created, mounted, destroyed 等钩子了
         
         所以其提供了actived（激活）和deactived（未激活）钩子，帮我们实现业务需求。 
    --&gt;

  &lt;/div&gt;
&lt;/template&gt;
</code></pre>
<p>VueCli 自定义创建项目</p>
<p>1.安装脚手架 (已安装)</p>
<pre><code>npm i @vue/cli -g
</code></pre>
<p>2.创建项目</p>
<pre><code>vue create hm-exp-mobile
</code></pre>
<ul>
<li><p>选项</p>
<p>  Vue CLI v5.0.8<br>  ? Please pick a preset:<br>Default ([Vue 3] babel, eslint)<br>Default ([Vue 2] babel, eslint)</p>
<blockquote>
<p>Manually select features     选自定义</p>
</blockquote>
</li>
<li><p>手动选择功能</p>
</li>
<li><p>选择vue的版本</p>
<pre><code>3.x
</code></pre>
<blockquote>
<p>2.x</p>
</blockquote>
</li>
<li><p>是否使用history模式（一般选择默认模式）</p>
</li>
<li><p>选择css预处理</p>
</li>
<li><p>选择eslint的风格 （eslint 代码规范的检验工具，检验代码是否符合规范）</p>
</li>
<li><p>比如：const age &#x3D; 18;   &#x3D;&gt;  报错！多加了分号！后面有工具，一保存，全部格式化成最规范的样子</p>
<p>选择校验的时机 （直接回车）</p>
<p>选择配置文件的生成方式 （直接回车）</p>
<p>是否保存预设，下次直接使用？  &#x3D;&gt;   不保存，输入 N</p>
<ul>
<li>等待安装，项目初始化完成</li>
</ul>
</li>
</ul>
<p>ESlint代码规范及手动修复</p>
<p>代码规范：一套写代码的约定规则。例如：赋值符号的左右是否需要空格？一句结束是否是要加;？… </p>
<p>没有规矩不成方圆  </p>
<p>ESLint:是一个代码检查工具，用来检查你的代码是否符合指定的规则(你和你的团队可以自行约定一套规则)。在创建项目时，我们使用的是 JavaScript Standard Style 代码风格的规则。</p>
<p>1.JavaScript Standard Style 规范说明</p>
<p>建议把：<a target="_blank" rel="noopener" href="https://standardjs.com/rules-zhcn.html">https://standardjs.com/rules-zhcn.html</a> 看一遍，然后在写的时候,  遇到错误就查询解决。</p>
<p>下面是这份规则中的一小部分：</p>
<ul>
<li>字符串使用单引号 – 需要转义的地方除外</li>
<li>无分号 – 这没什么不好。不骗你！</li>
<li>关键字后加空格 if (condition) { … }</li>
<li>函数名后加空格 function name (arg) { … }</li>
<li>坚持使用全等 &#x3D;&#x3D;&#x3D; 摒弃 &#x3D;&#x3D; 一但在需要检查 null || undefined 时可以使用 obj &#x3D;&#x3D; null</li>
<li>……</li>
</ul>
<p>通过eslint插件来实现自动修正</p>
<ol>
<li>eslint会自动高亮错误显示</li>
<li>通过配置，eslint会自动帮助我们修复错误</li>
</ol>
<ul>
<li><p>如何安装</p>
</li>
<li><p>如何配置</p>
<p>  &#x2F;&#x2F; 当保存的时候，eslint自动帮我们修复错误<br>  “editor.codeActionsOnSave”: {<br>  “source.fixAll”: true<br>  },<br>  &#x2F;&#x2F; 保存代码，不自动格式化<br>  “editor.formatOnSave”: false</p>
</li>
<li><p>注意：eslint的配置文件必须在根目录下，这个插件才能才能生效。打开项目必须以根目录打开，一次打开一个项目</p>
</li>
<li><p>注意：使用了eslint校验之后，把vscode带的那些格式化工具全禁用了 Beatify</p>
</li>
</ul>
<p>settings.json 参考</p>
<pre><code>&#123;
    &quot;window.zoomLevel&quot;: 2,
    &quot;workbench.iconTheme&quot;: &quot;vscode-icons&quot;,
    &quot;editor.tabSize&quot;: 2,
    &quot;emmet.triggerExpansionOnTab&quot;: true,
    // 当保存的时候，eslint自动帮我们修复错误
    &quot;editor.codeActionsOnSave&quot;: &#123;
        &quot;source.fixAll&quot;: true
    &#125;,
    // 保存代码，不自动格式化
    &quot;editor.formatOnSave&quot;: false
&#125;
</code></pre>
<p>Vuex</p>
<p>(<a target="_blank" rel="noopener" href="https://vuex.vuejs.org/zh/">https://vuex.vuejs.org/zh/</a>) 概述</p>
<p>Vuex 是一个 Vue 的 状态管理工具，状态就是数据。</p>
<p>大白话：Vuex 是一个插件，可以帮我们管理 Vue 通用的数据 (多组件共享的数据)。例如：购物车数据   个人信息数</p>
<p>优势</p>
<ul>
<li>共同维护一份数据，数据集中化管理</li>
<li>响应式变化</li>
<li>操作简洁 (vuex提供了一些辅助函数)</li>
</ul>
<p>新建 store&#x2F;index.js 专门存放 vuex</p>
<pre><code>为了维护项目目录的整洁，在src目录下新建一个store目录其下放置一个index.js文件。 (和 router/index.js 类似)

// 导入 vue
import Vue from &#39;vue&#39;
// 导入 vuex
import Vuex from &#39;vuex&#39;
// vuex也是vue的插件, 需要use一下, 进行插件的安装初始化
Vue.use(Vuex)

// 创建仓库 store
const store = new Vuex.Store()

// 导出仓库
export default store
</code></pre>
<p>在 main.js 中导入挂载到 Vue 实例上</p>
<pre><code>import Vue from &#39;vue&#39;
import App from &#39;./App.vue&#39;
import store from &#39;./store&#39;

Vue.config.productionTip = false

new Vue(&#123;
  render: h =&gt; h(App),
  store
&#125;).$mount(&#39;#app&#39;)
</code></pre>
<p>此刻起, 就成功创建了一个 空仓库!!</p>
<p>核心概念 - state 状态</p>
<p>1.目标</p>
<p>明确如何给仓库 提供 数据，如何 使用 仓库的数据</p>
<p>2.提供数据和获取数据</p>
<p>State提供唯一的公共数据源，所有共享的数据都要统一放到Store中的State中存储。</p>
<p>打开项目中的store.js文件，在state对象中可以添加我们要共享的数据。</p>
<p>第一种获取数据方法</p>
<pre><code>const store = new Vuex.Store(&#123;
  // state仓库中的数据，可以所以组件共享
  // 有两种方式可以获取数据
  // 1.直接在渲染的地方
  //      模板中：     &#123;&#123; $store.state.xxx &#125;&#125;
  //      组件逻辑中：  this.$store.state.xxx
  //      JS模块中：   store.state.xxx
  // 2.通过mapstate获取数据
  state: &#123;
    count: 100,
    title: &#39;大标题&#39;
  &#125;
&#125;)
</code></pre>
<p>通过辅助函数  - mapState获取 state中的数据</p>
<p>第二种获取数据的方法</p>
<pre><code>&lt;template&gt;
  &lt;div class=&quot;box&quot;&gt;
    &lt;h2&gt;Son1 子组件&lt;/h2&gt;
    &lt;!-- 直接用属性名即可 --&gt;
    从vuex中获取的值: &lt;label&gt;&#123;&#123; count &#125;&#125;&lt;/label&gt;
    &lt;br&gt;
    &lt;button&gt;值 + 1&lt;/button&gt;
  &lt;/div&gt;
&lt;/template&gt;

&lt;script&gt;
// 第一步导入mapstate
import &#123; mapState &#125; from &#39;vuex&#39;
export default &#123;
  name: &#39;Son1Com&#39;,
  computed: &#123;
    // 第二步：在computed中以数组的形式导入属性
    ...mapState([&#39;count&#39;, &#39;title&#39;])
  &#125;
&#125;
&lt;/script&gt;
</code></pre>
<p>六、开启严格模式及Vuex的单项数据流</p>
<p>1.目标</p>
<p>明确 vuex 同样遵循单向数据流，组件中不能直接修改仓库的数据（与props一样，只能获取数据，不能直接修改数据） </p>
<p>2.开启严格模式</p>
<p>通过 strict: true 可以开启严格模式,开启严格模式后，直接修改state中的值会报错</p>
<p>七、核心概念-mutations（修改仓库的方法）</p>
<p>1.定义mutations</p>
<pre><code>const store  = new Vuex.Store(&#123;
  state: &#123;
    count: 0
  &#125;,
  // 定义mutations
  mutations: &#123;
     
  &#125;
&#125;)
</code></pre>
<p>2.格式说明</p>
<p>mutations是一个对象，对象中存放修改state的方法</p>
<pre><code>mutations: &#123;
    // 方法里参数 第一个参数是当前store的state属性
    // payload 载荷 运输参数 调用mutaiions的时候 可以传递参数（传递载荷）
    addCount (state) &#123;
      state.count += 1
    &#125;
  &#125;,
</code></pre>
<p>3.组件中提交 mutations</p>
<pre><code>this.$store.commit(&#39;addCount&#39;)
</code></pre>
<p>八、带参数的 mutations</p>
<p>1.目标：</p>
<p>掌握 mutations 传参语法</p>
<p>2.语法</p>
<p>看下面这个案例，每次点击不同的按钮，加的值都不同，每次都要定义不同的mutations处理吗？</p>
<p>提交 mutation 是可以传递参数的  this.$store.commit(‘xxx’,  参数)</p>
<p>2.1 提供mutation函数（带参数）</p>
<pre><code>mutations: &#123;
  ...
  addCount (state, count) &#123;
    state.count = count
  &#125;
&#125;,
</code></pre>
<p>2.2 提交mutation</p>
<pre><code>handle ( ) &#123;
  this.$store.commit(&#39;addCount&#39;, 10)
&#125;
</code></pre>
<p>小tips: 提交的参数只能是一个, 如果有多个参数要传, 可以传递一个对象</p>
<pre><code>this.$store.commit(&#39;addCount&#39;, &#123;
  count: 10
&#125;)
</code></pre>
<p>十、练习-Vuex中的值和组件中的input双向绑定</p>
<p>1.目标</p>
<p>实时输入，实时更新，巩固 mutations 传参语法</p>
<p>2.实现步骤</p>
<p>App.vue</p>
<pre><code>&lt;template&gt;
  &lt;div id=&quot;app&quot;&gt;
    &lt;!-- 直接用即可 --&gt;
    &lt;h1&gt;根组件-&#123;&#123; $store.state.count &#125;&#125;-&#123;&#123; $store.state.title &#125;&#125;&lt;/h1&gt;
    &lt;!-- ：value显示mapstate传过来的值,,@input是处理数据再传递给仓库 --&gt;
    &lt;input type=&quot;text&quot; :value=&quot;count&quot; @input=&quot;handleCount&quot;&gt;
    &lt;Son1&gt;&lt;/Son1&gt;
    &lt;hr&gt;
    &lt;Son2&gt;&lt;/Son2&gt;
  &lt;/div&gt;
&lt;/template&gt;

&lt;script&gt;
import Son1 from &#39;./components/Son1.vue&#39;
import Son2 from &#39;./components/Son2.vue&#39;
// 获取仓库的数据
import &#123; mapState &#125; from &#39;vuex&#39;
export default &#123;
  name: &#39;app&#39;,
  data: function () &#123;
    return &#123;

    &#125;
  &#125;,
  computed: &#123;
    ...mapState([&#39;count&#39;])
  &#125;,
  methods: &#123;
    handleCount (e) &#123;
      // e为监听对话框整个事件
      // e.target.value就是对话框的值
      // 给仓库提交修改数据的请求
      this.$store.commit(&#39;handleCount&#39;, e.target.value)
    &#125;
  &#125;,
  components: &#123;
    Son1,
    Son2
  &#125;,
  created () &#123;
    console.log(this.$store)
  &#125;
&#125;
&lt;/script&gt;
</code></pre>
<p>index.js</p>
<pre><code>import Vue from &#39;vue&#39;
import Vuex from &#39;vuex&#39;

Vue.use(Vuex)

const store = new Vuex.Store(&#123;
  state: &#123;
    count: 100,
    title: &#39;大标题&#39;
  &#125;,
  // mutations提供修改数据的方法
  mutations: &#123;
    // 提供向仓库添加数据的方法（）中的第一个都是state
    Add (state, n) &#123;
      // console.log(11)
      // 通过store.state.count来获取数据
      store.state.count += n
    &#125;,
    // 处理数据count 的方法
    handleCount (state, n) &#123;
      // 将仓库中的count的数据直接赋值就可以实现修改
      store.state.count = n
    &#125;
  &#125;
&#125;)

export default store
</code></pre>
<p>十一、辅助函数- mapMutations</p>
<p>mapMutations和mapState很像，它把位于mutations中的方法提取了出来，我们可以将它导入</p>
<pre><code>import  &#123; mapMutations &#125; from &#39;vuex&#39;
methods: &#123;
    ...mapMutations([&#39;addCount&#39;])
&#125;
</code></pre>
<p>上面代码的含义是将mutations的方法导入了methods中，等价于</p>
<pre><code>methods: &#123;
      // commit(方法名, 载荷参数)
      addCount () &#123;
          this.$store.commit(&#39;addCount&#39;)
      &#125;
 &#125;
</code></pre>
<p>此时，就可以直接通过this.addCount调用了</p>
<pre><code>&lt;button @click=&quot;addCount(1)&quot;&gt;值+1&lt;/button&gt;
</code></pre>
<p>但是请注意： Vuex中mutations中要求不能写异步代码，如果有异步的ajax请求，应该放置在actions中</p>
<p>十二、核心概念 - actions</p>
<p>state是存放数据的，mutations是同步更新数据 (便于监测数据的变化, 更新视图等, 方便于调试工具查看变化)，</p>
<p>actions则负责进行异步操作</p>
<p>说明：mutations必须是同步的</p>
<p>需求: 一秒钟之后, 要给一个数 去修改state</p>
<p>1.定义actions</p>
<pre><code>mutations: &#123;
  changeCount (state, newCount) &#123;
    state.count = newCount
  &#125;
&#125;


actions: &#123;
  setAsyncCount (context, num) &#123;
    // 一秒后, 给一个数, 去修改 num
    setTimeout(() =&gt; &#123;
      context.commit(&#39;changeCount&#39;, num)
    &#125;, 1000)
  &#125;
&#125;,
</code></pre>
<p>2.组件中通过dispatch调用</p>
<pre><code>setAsyncCount () &#123;
  this.$store.dispatch(&#39;setAsyncCount&#39;, 666)
&#125;
</code></pre>
<p>十三、辅助函数 -mapActions</p>
<p>1.目标：掌握辅助函数 mapActions，映射方法</p>
<p>mapActions 是把位于 actions中的方法提取了出来，映射到组件methods中</p>
<p>Son2.vue</p>
<pre><code>import &#123; mapActions &#125; from &#39;vuex&#39;
methods: &#123;
   ...mapActions([&#39;changeCountAction&#39;])
&#125;

//mapActions映射的代码 本质上是以下代码的写法
//methods: &#123;
//  changeCountAction (n) &#123;
//    this.$store.dispatch(&#39;changeCountAction&#39;, n)
//  &#125;,
//&#125;
</code></pre>
<p>直接通过 this.方法 就可以调用</p>
<pre><code>&lt;button @click=&quot;changeCountAction(200)&quot;&gt;+异步&lt;/button&gt;
</code></pre>
<p>十四、核心概念 - getters</p>
<p>除了state之外，有时我们还需要从state中筛选出符合条件的一些数据，这些数据是依赖state的，此时会用到getters</p>
<p>例如，state中定义了list，为1-10的数组，</p>
<pre><code>state: &#123;
    list: [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
&#125;
</code></pre>
<p>组件中，需要显示所有大于5的数据，正常的方式，是需要list在组件中进行再一步的处理，但是getters可以帮助我们实现它</p>
<p>1.定义getters</p>
<pre><code>  getters: &#123;
    // getters函数的第一个参数是 state
    // 必须要有返回值
     filterList:  state =&gt;  state.list.filter(item =&gt; item &gt; 5)
  &#125;
</code></pre>
<p>2.使用getters</p>
<p>2.1原始方式-$store</p>
<pre><code>&lt;div&gt;&#123;&#123; $store.getters.filterList &#125;&#125;&lt;/div&gt;
</code></pre>
<p>2.2辅助函数 - mapGetters</p>
<pre><code>computed: &#123; 
    ...mapGetters([&#39;filterList&#39;])
&#125;

 &lt;div&gt;&#123;&#123; filterList &#125;&#125;&lt;/div&gt;
</code></pre>
<p>十五、使用小结</p>
<p>十六、核心概念 - module</p>
<p>1.目标</p>
<p>掌握核心概念 module 模块的创建</p>
<p>2.问题</p>
<p>由于使用单一状态树，应用的所有状态会集中到一个比较大的对象。当应用变得非常复杂时，store 对象就有可能变得相当臃肿。</p>
<p>这句话的意思是，如果把所有的状态都放在state中，当项目变得越来越大的时候，Vuex会变得越来越难以维护</p>
<p>由此，又有了Vuex的模块化</p>
<p>3.模块定义 - 准备 state</p>
<p>定义两个模块   user 和  setting</p>
<p>user中管理用户的信息状态  userInfo  modules&#x2F;user.js</p>
<pre><code>const state = &#123;
  userInfo: &#123;
    name: &#39;zs&#39;,
    age: 18
  &#125;
&#125;

const mutations = &#123;&#125;

const actions = &#123;&#125;

const getters = &#123;&#125;

export default &#123;
  state,
  mutations,
  actions,
  getters
&#125;
</code></pre>
<p>setting中管理项目应用的  主题色 theme，描述 desc， modules&#x2F;setting.js</p>
<pre><code>const state = &#123;
  theme: &#39;dark&#39;
  desc: &#39;描述真呀真不错&#39;
&#125;

const mutations = &#123;&#125;

const actions = &#123;&#125;

const getters = &#123;&#125;

export default &#123;
  state,
  mutations,
  actions,
  getters
&#125;
</code></pre>
<p>在store&#x2F;index.js文件中的modules配置项中，注册这两个模块</p>
<pre><code>import user from &#39;./modules/user&#39;
import setting from &#39;./modules/setting&#39;

const store = new Vuex.Store(&#123;
    modules:&#123;
        user,
        setting
    &#125;
&#125;)
</code></pre>
<p>使用模块中的数据,  可以直接通过模块名访问 $store.state.模块名.xxx  &#x3D;&gt;  $store.state.setting.desc</p>
<p>也可以通过 mapState 映射</p>
<p>十七、获取模块内的state数据</p>
<p>1.目标：</p>
<p>掌握模块中 state 的访问语法</p>
<p>尽管已经分模块了，但其实子模块的状态，还是会挂到根级别的 state 中，属性名就是模块名</p>
<p>2.使用模块中的数据</p>
<ol>
<li>直接通过模块名访问 $store.state.模块名.xxx</li>
<li>通过 mapState 映射：<ol>
<li>默认根级别的映射  mapState([ ‘xxx’ ])     </li>
<li>子模块的映射 ：mapState(‘模块名’, [‘xxx’])  -  需要开启命名空间 namespaced:true</li>
</ol>
</li>
</ol>
<p>modules&#x2F;user.js</p>
<pre><code>const state = &#123;
  userInfo: &#123;
    name: &#39;zs&#39;,
    age: 18
  &#125;,
  myMsg: &#39;我的数据&#39;
&#125;

const mutations = &#123;
  updateMsg (state, msg) &#123;
    state.myMsg = msg
  &#125;
&#125;

const actions = &#123;&#125;

const getters = &#123;&#125;

export default &#123;
  namespaced: true,
  state,
  mutations,
  actions,
  getters
&#125;
</code></pre>
<p>3.代码示例</p>
<p>$store直接访问</p>
<pre><code>$store.state.user.userInfo.name
</code></pre>
<p>mapState辅助函数访问</p>
<pre><code>...mapState(&#39;user&#39;, [&#39;userInfo&#39;]),
...mapState(&#39;setting&#39;, [&#39;theme&#39;, &#39;desc&#39;]),
</code></pre>
<p>十八、获取模块内的getters数据</p>
<p>1.目标：</p>
<p>掌握模块中 getters 的访问语</p>
<p>2.语法：</p>
<p>使用模块中 getters 中的数据： </p>
<ol>
<li>直接通过模块名访问$store.getters[‘模块名&#x2F;xxx ‘]</li>
<li>通过 mapGetters 映射      <ol>
<li>默认根级别的映射  mapGetters([ ‘xxx’ ])</li>
<li>子模块的映射  mapGetters(‘模块名’, [‘xxx’]) -  需要开启命名空间</li>
</ol>
</li>
</ol>
<p>3.代码演示</p>
<p>modules&#x2F;user.js</p>
<pre><code>const getters = &#123;
  // 分模块后，state指代子模块的state
  UpperCaseName (state) &#123;
    return state.userInfo.name.toUpperCase()
  &#125;
&#125;
</code></pre>
<p>Son1.vue 直接访问getters</p>
<pre><code>&lt;!-- 测试访问模块中的getters - 原生 --&gt;
&lt;div&gt;&#123;&#123; $store.getters['user/UpperCaseName'] &#125;&#125;&lt;/div&gt;
</code></pre>
<p>Son2.vue 通过命名空间访问</p>
<pre><code>computed:&#123;
  ...mapGetters(&#39;user&#39;, [&#39;UpperCaseName&#39;])
&#125;
</code></pre>
<p>十九、获取模块内的mutations方法</p>
<p>1.目标：</p>
<p>掌握模块中 mutation 的调用语法</p>
<p>2.注意：</p>
<p>默认模块中的 mutation 和 actions 会被挂载到全局，需要开启命名空间，才会挂载到子模块。</p>
<p>3.调用方式：</p>
<ol>
<li>直接通过 store 调用   $store.commit(‘模块名&#x2F;xxx ‘,  额外参数)</li>
<li>通过 mapMutations 映射    <ol>
<li>默认根级别的映射  mapMutations([ ‘xxx’ ])     </li>
<li>子模块的映射 mapMutations(‘模块名’, [‘xxx’])  -  需要开启命名空间</li>
</ol>
</li>
</ol>
<p>4.代码实现</p>
<p>modules&#x2F;user.js</p>
<pre><code>const mutations = &#123;
  setUser (state, newUserInfo) &#123;
    state.userInfo = newUserInfo
  &#125;
&#125;
</code></pre>
<p>modules&#x2F;setting.js</p>
<pre><code>const mutations = &#123;
  setTheme (state, newTheme) &#123;
    state.theme = newTheme
  &#125;
&#125;
</code></pre>
<p>Son1.vue</p>
<pre><code>&lt;button @click=&quot;updateUser&quot;&gt;更新个人信息&lt;/button&gt; 
&lt;button @click=&quot;updateTheme&quot;&gt;更新主题色&lt;/button&gt;


export default &#123;
  methods: &#123;
    updateUser () &#123;
      // $store.commit(&#39;模块名/mutation名&#39;, 额外传参)
      this.$store.commit(&#39;user/setUser&#39;, &#123;
        name: &#39;xiaowang&#39;,
        age: 25
      &#125;)
    &#125;, 
    updateTheme () &#123;
      this.$store.commit(&#39;setting/setTheme&#39;, &#39;pink&#39;)
    &#125;
  &#125;
&#125;
</code></pre>
<p>Son2.vue</p>
<pre><code>&lt;button @click=&quot;setUser(&#123; name: &#39;xiaoli&#39;, age: 80 &#125;)&quot;&gt;更新个人信息&lt;/button&gt;
&lt;button @click=&quot;setTheme(&#39;skyblue&#39;)&quot;&gt;更新主题&lt;/button&gt;

methods:&#123;
// 分模块的映射
...mapMutations(&#39;setting&#39;, [&#39;setTheme&#39;]),
...mapMutations(&#39;user&#39;, [&#39;setUser&#39;]),
&#125;
</code></pre>
<p>二十、获取模块内的actions方法</p>
<p>1.目标：</p>
<p>掌握模块中 action 的调用语法 (同理 - 直接类比 mutation 即可)</p>
<p>2.注意：</p>
<p>默认模块中的 mutation 和 actions 会被挂载到全局，需要开启命名空间，才会挂载到子模块。</p>
<p>3.调用语法：</p>
<ol>
<li>直接通过 store 调用   $store.dispatch(‘模块名&#x2F;xxx ‘,  额外参数)</li>
<li>通过 mapActions 映射     <ol>
<li>默认根级别的映射  mapActions([ ‘xxx’ ])     </li>
<li>子模块的映射 mapActions(‘模块名’, [‘xxx’])  -  需要开启命名空间</li>
</ol>
</li>
</ol>
<p>4.代码实现</p>
<p>需求：</p>
<p>modules&#x2F;user.js</p>
<pre><code>const actions = &#123;
  setUserSecond (context, newUserInfo) &#123;
    // 将异步在action中进行封装
    setTimeout(() =&gt; &#123;
      // 调用mutation   context上下文，默认提交的就是自己模块的action和mutation
      context.commit(&#39;setUser&#39;, newUserInfo)
    &#125;, 1000)
  &#125;
&#125;
</code></pre>
<p>Son1.vue  直接通过store调用</p>
<pre><code>&lt;button @click=&quot;updateUser2&quot;&gt;一秒后更新信息&lt;/button&gt;

methods:&#123;
    updateUser2 () &#123;
      // 调用action dispatch
      this.$store.dispatch(&#39;user/setUserSecond&#39;, &#123;
        name: &#39;xiaohong&#39;,
        age: 28
      &#125;)
    &#125;,
&#125;
</code></pre>
<p>Son2.vue mapActions映射</p>
<pre><code>&lt;button @click=&quot;setUserSecond(&#123; name: &#39;xiaoli&#39;, age: 80 &#125;)&quot;&gt;一秒后更新信息&lt;/button&gt;

methods:&#123;
  ...mapActions(&#39;user&#39;, [&#39;setUserSecond&#39;])
&#125;
</code></pre>
<p>二十一、Vuex模块化的使用小结</p>
<p>1.直接使用</p>
<ol>
<li>state –&gt; $store.state.模块名.数据项名</li>
<li>getters –&gt; $store.getters[‘模块名&#x2F;属性名’]</li>
<li>mutations –&gt; $store.commit(‘模块名&#x2F;方法名’, 其他参数)</li>
<li>actions –&gt; $store.dispatch(‘模块名&#x2F;方法名’, 其他参数)</li>
</ol>
<p>2.借助辅助方法使用</p>
<p>1.import { mapXxxx, mapXxx } from ‘vuex’</p>
<p>computed、methods: {</p>
<pre><code> // ...mapState、...mapGetters放computed中；

//  ...mapMutations、...mapActions放methods中；

...mapXxxx(&#39;模块名&#39;, [&#39;数据项|方法&#39;]),

...mapXxxx(&#39;模块名&#39;, &#123; 新的名字: 原来的名字 &#125;),
</code></pre>
<p>}</p>
<p>2.组件中直接使用 属性  或 方法 @click&#x3D;”updateAge(2)”</p>
<p>二十二、综合案例 - 创建项目</p>
<ol>
<li><p>脚手架新建项目 (注意：勾选vuex)<br>版本说明：<br>vue2   vue-router3   vuex3<br>vue3  vue-router4  vuex4&#x2F;pinia</p>
<p> vue create vue-cart-demo</p>
</li>
<li><p>将原本src内容清空，替换成教学资料的《vuex-cart-准备代码》</p>
</li>
</ol>
<p>需求：</p>
<ol>
<li>发请求动态渲染购物车，数据存vuex （存cart模块， 将来还会有user模块，article模块…）</li>
<li>数字框可以修改数据</li>
<li>动态计算总价和总数量</li>
</ol>
<p>二十三、综合案例-构建vuex-cart模块</p>
<ol>
<li><p>新建 store&#x2F;modules&#x2F;cart.js</p>
<p> export default {<br>   namespaced: true,<br>   state () {<br> return {<br>   list: []<br> }<br>   },<br> }</p>
</li>
<li><p>挂载到 vuex 仓库上 store&#x2F;cart.js</p>
<p> import Vuex from ‘vuex’<br> import Vue from ‘vue’</p>
<p> import cart from ‘.&#x2F;modules&#x2F;cart’</p>
<p> Vue.use(Vuex)</p>
<p> const store &#x3D; new Vuex.Store({<br>   modules: {<br> cart<br>   }<br> })</p>
<p> export default store</p>
</li>
</ol>
<p>二十四、综合案例-准备后端接口服务环境(了解)</p>
<ol>
<li><p>安装全局工具 json-server （全局工具仅需要安装一次）</p>
<p> yarn global add json-server 或 npm i json-server  -g</p>
</li>
<li><p>代码根目录新建一个 db 目录</p>
</li>
<li><p>将资料 index.json 移入 db 目录</p>
</li>
<li><p>进入 db 目录，执行命令，启动后端接口服务 (使用–watch 参数 可以实时监听 json 文件的修改)(不能关闭)</p>
<p> json-server  –watch  index.json</p>
</li>
</ol>
<p>二十五、综合案例-请求动态渲染数据</p>
<p>1.目标</p>
<p>请求获取数据存入 vuex, 映射渲染</p>
<ol>
<li><p>安装 axios</p>
<p> yarn add axios</p>
</li>
<li><p>准备actions 和 mutations</p>
<p> import axios from ‘axios’</p>
<p> export default {<br>   namespaced: true,<br>   state () {<br> return {<br>   list: []<br> }<br>   },<br>   mutations: {<br> updateList (state, payload) {<br>   state.list &#x3D; payload<br> }<br>   },<br>   actions: {<br> async getList (ctx) {<br>   const res &#x3D; await axios.get(‘<a target="_blank" rel="noopener" href="http://localhost:3000/cart">http://localhost:3000/cart</a>‘)<br>   ctx.commit(‘updateList’, res.data)<br> }<br>   }<br> }</p>
</li>
<li><p>App.vue页面中调用 action,  获取数据</p>
<p> import { mapState } from ‘vuex’</p>
<p> export default {<br>   name: ‘App’,<br>   components: {<br> CartHeader,<br> CartFooter,<br> CartItem<br>   },<br>   created () {<br> this.$store.dispatch(‘cart&#x2F;getList’)<br>   },<br>   computed: {<br> …mapState(‘cart’, [‘list’])<br>   }<br> }</p>
</li>
<li><p>动态渲染</p>
 <!-- 商品 Item 项组件 -->
<p> <cart-item v-for="item in list" :key="item.id" :item="item"></cart-item></p>
</li>
</ol>
<p>cart-item.vue</p>
<pre><code>&lt;template&gt;
  &lt;div class=&quot;goods-container&quot;&gt;
    &lt;!-- 左侧图片区域 --&gt;
    &lt;div class=&quot;left&quot;&gt;
      &lt;img :src=&quot;item.thumb&quot; class=&quot;avatar&quot; alt=&quot;&quot;&gt;
    &lt;/div&gt;
    &lt;!-- 右侧商品区域 --&gt;
    &lt;div class=&quot;right&quot;&gt;
      &lt;!-- 标题 --&gt;
      &lt;div class=&quot;title&quot;&gt;&#123;&#123;item.name&#125;&#125;&lt;/div&gt;
      &lt;div class=&quot;info&quot;&gt;
        &lt;!-- 单价 --&gt;
        &lt;span class=&quot;price&quot;&gt;￥&#123;&#123;item.price&#125;&#125;&lt;/span&gt;
        &lt;div class=&quot;btns&quot;&gt;
          &lt;!-- 按钮区域 --&gt;
          &lt;button class=&quot;btn btn-light&quot;&gt;-&lt;/button&gt;
          &lt;span class=&quot;count&quot;&gt;&#123;&#123;item.count&#125;&#125;&lt;/span&gt;
          &lt;button class=&quot;btn btn-light&quot;&gt;+&lt;/button&gt;
        &lt;/div&gt;
      &lt;/div&gt;
    &lt;/div&gt;
  &lt;/div&gt;
&lt;/template&gt;

&lt;script&gt;
export default &#123;
  name: &#39;CartItem&#39;,
  props: &#123;
    item: Object
  &#125;,
  methods: &#123;

  &#125;
&#125;
&lt;/script&gt;
</code></pre>
<p>二十六、综合案例-修改数量</p>
<ol>
<li><p>注册点击事件</p>
 <!-- 按钮区域 -->
<p> &lt;button class&#x3D;”btn btn-light” @click&#x3D;”onBtnClick(-1)”&gt;-</button><br> <span class="count"></span><br> &lt;button class&#x3D;”btn btn-light” @click&#x3D;”onBtnClick(1)”&gt;+</button></p>
</li>
<li><p>页面中dispatch action</p>
<p> onBtnClick (step) {<br>   const newCount &#x3D; this.item.count + step<br>   if (newCount &lt; 1) return</p>
<p>   &#x2F;&#x2F; 发送修改数量请求<br>   this.$store.dispatch(‘cart&#x2F;updateCount’, {<br> id: this.item.id,<br> count: newCount<br>   })<br> }</p>
</li>
<li><p>提供action函数</p>
<p> async updateCount (ctx, payload) {<br>   await axios.patch(‘<a target="_blank" rel="noopener" href="http://localhost:3000/cart/">http://localhost:3000/cart/</a>‘ + payload.id, {<br> count: payload.count<br>   })<br>   ctx.commit(‘updateCount’, payload)<br> }</p>
</li>
<li><p>提供mutation处理函数</p>
<p> mutations: {<br>   …,<br>   updateCount (state, payload) {<br> const goods &#x3D; state.list.find((item) &#x3D;&gt; item.id &#x3D;&#x3D;&#x3D; payload.id)<br> goods.count &#x3D; payload.count<br>   }<br> },</p>
</li>
</ol>
<p>二十七、综合案例-底部总价展示</p>
<ol>
<li><p>提供getters</p>
<p> getters: {<br>   total(state) {<br> return state.list.reduce((p, c) &#x3D;&gt; p + c.count, 0);<br>   },<br>   totalPrice (state) {<br> return state.list.reduce((p, c) &#x3D;&gt; p + c.count * c.price, 0);<br>   },<br> },</p>
</li>
<li><p>动态渲染</p>
 <template>
   <div class="footer-container">
     <!-- 中间的合计 -->
     <div>
       <span>共  件商品，合计：</span>
       <span class="price">￥</span>
     </div>
     <!-- 右侧结算按钮 -->
     <button class="btn btn-success btn-settle">结算</button>
   </div>
 </template>
 
 <script>
 import { mapGetters } from 'vuex'
 export default {
   name: 'CartFooter',
   computed: {
     ...mapGetters('cart', ['total', 'totalPrice'])
   }
 }
 </script></li>
</ol>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="http://example.com">yxx</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="http://example.com/2024/02/17/vue/">http://example.com/2024/02/17/vue/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://example.com" target="_blank">yxx</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"></div><div class="post_share"><div class="social-share" data-image="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="next-post pull-full"><a href="/2023/10/17/git/" title="git学习笔记"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">git学习笔记</div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">yxx</div><div class="author-info__description"></div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">2</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">0</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/02/17/vue/" title="vue学习笔记">vue学习笔记</a><time datetime="2024-02-17T13:12:54.255Z" title="发表于 2024-02-17 21:12:54">2024-02-17</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/10/17/git/" title="git学习笔记">git学习笔记</a><time datetime="2023-10-16T16:00:00.000Z" title="发表于 2023-10-17 00:00:00">2023-10-17</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2024 By yxx</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js?v=4.12.0"></script><script src="/js/main.js?v=4.12.0"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.32/dist/fancybox/fancybox.umd.min.js"></script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>